//#define PRTBOARD
#undef PRTBOARD
#define HORSECK
//#undef HORSECK

/*
Eychessu - a Chinese Chess Program Designed by Edward Yu, Version: 1.885t

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

//extern int printed;
//#include "StdAfx.h"
#include ".\Board.h"
#include "pregen.h"
#include <memory.h>
#include <stdio.h>
extern int mf;  //1110 from eychessu param
extern int mf2;
//1109 extern int lmrparm1, lmrparm2, lmrparm3;
extern int POPCNT_CPU;
#define HistValMax 32000 //16384
#define THREAT_MARGIN 96
//macros
//#define TABMOVE(x, y) tabptr->from=x;tabptr->dest=y
//#define TABMOVE(x, y) tabptr->table.move=(x<<8)+y
#define TABMOVE(x, y) tabptr->tabentry=(x<<8)+y
//#define NCTABMOVE(x, y) ncaptabptr->from=x;ncaptabptr->dest=y
//#define NCTABMOVE(x, y) ncaptabptr->table.move=(x<<8)+y
//* tabval clear to 0
#define NCTABMOVE(x, y) ncaptabptr->tabentry=(x<<8)+y
#define HistoryMax 16384
//extern int RCH_count;
//extern short pointtable[BOARD_SIZE-7][16][2]; //[10][2];
extern short pointtable[10][10][9];
extern short eg_pointtable[10][10][9];
//extern short abspointtable[10][10][9];
//extern char pointtableABS[BOARD_SIZE-7][16]; //[10]; //[16]; //[32]; //[34][90];
extern short abs_pointtable[10][10][9];
//extern int g_KingMoves[BOARD_SIZE-7][8]; //[5];
//extern unsigned char g_advelemoves[BOARD_SIZE-7][4]; //[5];
//extern unsigned char g_RookMoves[BOARD_SIZE-7][4][16]; //[10];
//extern unsigned char g_ElephantEyes[BOARD_SIZE][4];
extern unsigned char g_KnightMoves[BOARD_SIZE-7][16]; //[12];
//extern short g_KnightMoves[BOARD_SIZE-7][16]; //[12];
extern unsigned char g_HorseLegs[BOARD_SIZE-7][8];
extern unsigned char g_PawnMoves[BOARD_SIZE-7][2][4];
#ifdef HORSECK
extern unsigned char g_KnightChecks[BOARD_SIZE-7][18][2];
#endif
extern char *horsdiff;


static const char c_SideKnight[BOARD_SIZE-7] = {
    16,16,16,16,16,16,16,16,16,0,0,0,0,0,0,0,
    1, 0, 0, 0, 0, 0, 0, 0,-1, 0,0,0,0,0,0,0,
    1, 0, 0, 0, 0, 0, 0, 0,-1, 0,0,0,0,0,0,0,
    1, 0, 0, 0, 0, 0, 0, 0,-1, 0,0,0,0,0,0,0,
    1, 0, 0, 0, 0, 0, 0, 0,-1, 0,0,0,0,0,0,0,
    1, 0, 0, 0, 0, 0, 0, 0,-1, 0,0,0,0,0,0,0,
    1, 0, 0, 0, 0, 0, 0, 0,-1, 0,0,0,0,0,0,0,
    1, 0, 0, 0, 0, 0, 0, 0,-1, 0,0,0,0,0,0,0,
    1, 0, 0, 0, 0, 0, 0, 0,-1, 0,0,0,0,0,0,0,
    -16,-16,-16,-16,-16,-16,-16,-16,-16
}; //, 0,0,0,0,0,0,0};
extern int p_endgame;
extern HistStruct m_his_table[7][10][BOARD_SIZE]; //[10]; //[16]; //1017 per thd in Engine.cpp 
//extern HistStruct m_his_table[10][9][10];
//extern HistRecord m_hisrecord[384]; //[MAX_MOVE_NUM]; 512
//extern int  m_hisindex;
//extern int pointsum;
//extern unsigned int bitpiece;
//extern unsigned char piececnt[34];
//1105 extern 
int evalthreat[2]; //[0]=black attacking, [1]=white attacking (threatening)


#ifdef PRTBOARD
static const wchar_t PieceChar[34] =
{L'。', L'。', L'卒', L'兵', L'卒', L'兵', L'卒', L'兵', L'卒', L'兵', L'卒', L'兵', L'士', L'仕', L'士', L'仕',
 L'象', L'相', L'象', L'相', L'馬', L'傌', L'馬', L'傌', L'包', L'炮', L'包', L'炮', L'車', L'俥', L'車', L'俥', L'將', L'帥'
};
int prtboard=0;
int before_score=0;
void Board::print_board(int score) //for debug
{
//setlocale( LC_ALL, "chs" );
	if (prtboard<10)
	{
	  printf("\n");
    for (int i=0; i<10; i++)
    {	if (i==5) printf(" ----------------------------------\n");
    	for (int j=0; j<9; j++)
    	{
    	wprintf(L" %c ", PieceChar[piece[(i*16)+j]] );
    	}
    	printf("\n");
    	fflush(stdout);
    }
    prtboard++;
    printf("score=%d, ", score);
		before_score = score;
	}
}

void print_bonus(int score)
{
	if (prtboard<10)
	{
		printf("bonus score=%d\n", score - before_score);
	}
}
#endif


//extern unsigned char *c_LegalMoveTab;

static const unsigned char c_LegalMoveTab_[(BOARD_SIZE - 7) * 2] = {
//             0, 0, 0, 0, 0,  0,0,
    0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 2, 0, 4, 0, 2, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 3, 1, 3, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 4, 1, 0, 1, 4, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 3, 1, 3, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 2, 0, 4, 0, 2, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0,0,0,0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,0,0,0
    //,0,0,0,
    //0, 0, 0, 0
};
static const unsigned char *c_LegalMoveTab = c_LegalMoveTab_ + BOARD_SIZE - 7;

/*
static const unsigned char c_InFort[BOARD_SIZE-7] = {

   0, 0, 0, 1, 1, 1, 0, 0, 0, 0,0,0,0,0,0,0,
   0, 0, 0, 1, 1, 1, 0, 0, 0, 0,0,0,0,0,0,0,
   0, 0, 0, 1, 1, 1, 0, 0, 0, 0,0,0,0,0,0,0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,
   0, 0, 0, 1, 1, 1, 0, 0, 0, 0,0,0,0,0,0,0,
   0, 0, 0, 1, 1, 1, 0, 0, 0, 0,0,0,0,0,0,0,
   0, 0, 0, 1, 1, 1, 0, 0, 0}; //, 0,0,0,0,0,0,0};
*/
/*
static const unsigned char kingidxpos[18]={
3,4,5,
19,20,21,
35,36,37,
115,116,117,
131,132,133,
147,148,149};
char kingindex[BOARD_SIZE-7] =
    {-1,-1,-1,0,1,2,-1,-1,-1,      0,0,0,0,0,0,0,
     -1,-1,-1,3,4,5,-1,-1,-1,      0,0,0,0,0,0,0,
     -1,-1,-1,6,7,8,-1,-1,-1,      0,0,0,0,0,0,0,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,   0,0,0,0,0,0,0,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,      0,0,0,0,0,0,0,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,      0,0,0,0,0,0,0,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,     0,0,0,0,0,0,0,
     -1,-1,-1,9,10,11,-1,-1,-1,   0,0,0,0,0,0,0,
     -1,-1,-1,12,13,14,-1,-1,-1,   0,0,0,0,0,0,0,
     -1,-1,-1,15,16,17,-1,-1,-1
    }; //,   0,0,0,0,0,0,0};
*/
extern unsigned char kingidxpos[18];
extern char kingindex[BOARD_SIZE-7];
/*
unsigned char kingattkpt[18][4]=
{	{4,19,0,0},{3,5,20,0},{4,21,0,0},
	{3,20,35,0},{4,19,21,36},{5,20,37,0},
	{19,36,0,0},{20,35,37,0},{21,36,0,0},
	{116,131,0,0},{115,117,132,0},{116,133,0,0},
	{115,132,147,0},{116,131,133,148},{117,132,149,0},
  {131,148,0,0},{132,147,149,0},{133,148,0,0}};
*/
//old [0]=kingattk, [1]=rook/c/p File, [2]=rook/c/p Rank, [3]=rook/c/p king>pos  [4]=horse chk only,
// wchkidx = (chkidx &15) - 1;
// [0]=rook/c File, [1]=rook/c king>pos, [2]=rook/c king<pos
// [3]=upper rank horse chk king>pos [4]=upper rank horse chk king<pos [5]=lower rank horse chk king>pos [6]=lower rank horse chk king<pos
// [7]=pawn
// kingevas[wchkidx][kingidx][16]
static const unsigned short kingevas[8][18][16] = {	//[5]
/*
    {{0xff80, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0,0,0,0,0,0},
        {0xff80, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0,0,0,0,0,0},
        {0xff80, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0,0,0,0,0,0},
        {0x1000, 0xff80, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0,0,0,0,0,0},
        {0x0800, 0xff80, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0,0,0,0,0,0},
        {0x0400, 0xff80, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0,0,0,0,0,0},
        {0x1000, 0x1000, 0xff80, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0,0,0,0,0,0},
        {0x0800, 0x0800, 0xff80, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0,0,0,0,0,0},
        {0x0400, 0x0400, 0xff80, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0,0,0,0,0,0},
        {0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0xff80, 0x1000, 0x1000, 0,0,0,0,0,0},
        {0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0xff80, 0x0800, 0x0800, 0,0,0,0,0,0},
        {0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0xff80, 0x0400, 0x0400, 0,0,0,0,0,0},
        {0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0xff80, 0x1000, 0,0,0,0,0,0},
        {0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0xff80, 0x0800, 0,0,0,0,0,0},
        {0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0xff80, 0x0400, 0,0,0,0,0,0},
        {0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0xff80, 0,0,0,0,0,0},
        {0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0xff80, 0,0,0,0,0,0},
        {0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0xff80, 0,0,0,0,0,0}},
*/
    {{0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0,0,0,0,0,0},
        {0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0,0,0,0,0,0},
        {0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0,0,0,0,0,0},
        {0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0,0,0,0,0,0},
        {0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0,0,0,0,0,0},
        {0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0,0,0,0,0,0},
        {0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0,0,0,0,0,0},
        {0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0,0,0,0,0,0},
        {0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0,0,0,0,0,0},
        {0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0,0,0,0,0,0},
        {0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0,0,0,0,0,0},
        {0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0,0,0,0,0,0},
        {0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0,0,0,0,0,0},
        {0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0,0,0,0,0,0},
        {0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0,0,0,0,0,0},
        {0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0,0,0,0,0,0},
        {0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0,0,0,0,0,0},
        {0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0,0,0,0,0,0}},


    {{0xf000, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000, 0x0000, 0x0000},
        {0xf800, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000, 0x0000, 0x0000},
        {0xfc00, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000, 0x0000, 0x0000},
        {0x0000, 0xf000, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000, 0x0000},
        {0x0000, 0xf800, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000, 0x0000},
        {0x0000, 0xfc00, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000, 0x0000},
        {0x0000, 0x0000, 0xf000, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000},
        {0x0000, 0x0000, 0xf800, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000},
        {0x0000, 0x0000, 0xfc00, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0xf000, 0,0,0,0,0,0, 0x0000, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0xf800, 0,0,0,0,0,0, 0x0000, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0xfc00, 0,0,0,0,0,0, 0x0000, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0x0000, 0xf000, 0,0,0,0,0,0, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0x0000, 0xf800, 0,0,0,0,0,0, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0x0000, 0xfc00, 0,0,0,0,0,0, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0x0000, 0x0000, 0xf000, 0,0,0,0,0,0},
        {0,0,0,0,0,0, 0x0000, 0x0000, 0x0000, 0xf800, 0,0,0,0,0,0},
        {0,0,0,0,0,0, 0x0000, 0x0000, 0x0000, 0xfc00, 0,0,0,0,0,0}},

 {{0x1f80, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000, 0x0000, 0x0000},
        {0x0f80, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000, 0x0000, 0x0000},
        {0x0780, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000, 0x0000, 0x0000},
        {0x0000, 0x1f80, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000, 0x0000},
        {0x0000, 0x0f80, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000, 0x0000},
        {0x0000, 0x0780, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000, 0x0000},
        {0x0000, 0x0000, 0x1f80, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000},
        {0x0000, 0x0000, 0x0f80, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000},
        {0x0000, 0x0000, 0x0780, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0x1f80, 0,0,0,0,0,0, 0x0000, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0x0f80, 0,0,0,0,0,0, 0x0000, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0x0780, 0,0,0,0,0,0, 0x0000, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0x0000, 0x1f80, 0,0,0,0,0,0, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0x0000, 0x0f80, 0,0,0,0,0,0, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0x0000, 0x0780, 0,0,0,0,0,0, 0x0000},
        {0,0,0,0,0,0, 0x0000, 0x0000, 0x0000, 0x1f80, 0,0,0,0,0,0},
        {0,0,0,0,0,0, 0x0000, 0x0000, 0x0000, 0x0f80, 0,0,0,0,0,0},
        {0,0,0,0,0,0, 0x0000, 0x0000, 0x0000, 0x0780, 0,0,0,0,0,0}},

/*
    {{0x1000, 0x6c00, 0x2800, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000},
        {0x0800, 0x3600, 0x1400, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000},
        {0x0400, 0x1b00, 0x0a00, 0,0,0,0,0,0, 0,0,0,0,0,0, 0x0000},
        {0x6c00, 0x1000, 0x6c00, 0x2800, 0,0,0,0,0,0, 0,0,0,0,0,0},
        {0x3600, 0x0800, 0x3600, 0x1400, 0,0,0,0,0,0, 0,0,0,0,0,0},
        {0x1b00, 0x0400, 0x1b00, 0x0a00, 0,0,0,0,0,0, 0,0,0,0,0,0},
        {0x2800, 0x6c00, 0x1000, 0x6c00, 0x2800, 0,0,0,0,0,0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
        {0x1400, 0x3600, 0x0800, 0x3600, 0x1400, 0,0,0,0,0,0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
        {0x0a00, 0x1b00, 0x0400, 0x1b00, 0x0a00, 0,0,0,0,0,0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
        {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2800, 0x6c00, 0x1000, 0x6c00, 0x2800, 0,0,0,0,0,0},
        {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1400, 0x3600, 0x0800, 0x3600, 0x1400, 0,0,0,0,0,0},
        {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0a00, 0x1b00, 0x0400, 0x1b00, 0x0a00, 0,0,0,0,0,0},
        {0,0,0,0,0,0, 0x2800, 0x6c00, 0x1000, 0x6c00, 0,0,0,0,0,0},
        {0,0,0,0,0,0, 0x1400, 0x3600, 0x0800, 0x3600, 0,0,0,0,0,0},
        {0,0,0,0,0,0, 0x0a00, 0x1b00, 0x0400, 0x1b00, 0,0,0,0,0,0},
        {0,0,0,0,0,0, 0x0000, 0x2800, 0x6c00, 0x1000, 0,0,0,0,0,0},
        {0,0,0,0,0,0, 0x0000, 0x1400, 0x3600, 0x0800, 0,0,0,0,0,0},
        {0,0,0,0,0,0, 0x0000, 0x0a00, 0x1b00, 0x0400, 0,0,0,0,0,0}}
};
*/
// hors
       {{B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(01100000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00110000,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00011000,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00100000,00000000),
       	 B(01100000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00010000,00000000),
       	 B(00110000,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00001000,00000000),
       	 B(00011000,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},
  //----------------------------------------
       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00100000,00000000),
       	 B(01100000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00110000,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00011000,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00100000,00000000),
       	 B(01100000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00110000,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00011000,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00100000,00000000),
       	 B(01100000,00000000),
       	 B(00010000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00110000,00000000),
       	 B(00001000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00011000,00000000),
         B(00000100,00000000), 0,0,0,0,0,0}},
//=================================================================
       {{B(00010000,00000000),
       	 B(01100000,00000000),
       	 B(00100000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00001000,00000000),
       	 B(00110000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000100,00000000),
       	 B(00011000,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(01100000,00000000),
       	 B(00100000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00110000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00011000,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(01100000,00000000),
       	 B(00100000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00110000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00011000,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},
  //----------------------------------------
       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(01100000,00000000),
       	 B(00100000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00110000,00000000),
       	 B(00010000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00011000,00000000),
       	 B(00001000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(01100000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00110000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00011000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
         B(00000100,00000000), 0,0,0,0,0,0}},
//=================================================================
       {{B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00001100,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000110,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000011,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00001000,00000000),
       	 B(00001100,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000100,00000000),
       	 B(00000110,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000010,00000000),
       	 B(00000011,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},
  //----------------------------------------
       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00001100,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00000110,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000010,00000000),
       	 B(00000011,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00001100,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00000110,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000010,00000000),
       	 B(00000011,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00001100,00000000),
       	 B(00010000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00000110,00000000),
       	 B(00001000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000010,00000000),
       	 B(00000011,00000000),
         B(00000100,00000000), 0,0,0,0,0,0}},
         //=================================================================
       {{B(00010000,00000000),
       	 B(00001100,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00001000,00000000),
       	 B(00000110,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000100,00000000),
       	 B(00000011,00000000),
       	 B(00000010,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00001100,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00000110,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00000011,00000000),
       	 B(00000010,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00001100,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00000110,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00000011,00000000),
       	 B(00000010,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},
  //----------------------------------------
       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00001100,00000000),
       	 B(00001000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00000110,00000000),
       	 B(00000100,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00000011,00000000),
       	 B(00000010,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00001100,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00000110,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00000011,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
         B(00000100,00000000), 0,0,0,0,0,0}},

                  //------- pawn
       {{B(00111000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00011100,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00001110,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00111000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00011100,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00001110,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00111000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00011100,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001110,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},
  //----------------------------------------
       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00111000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00011100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00001110,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00111000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00011100,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00001110,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00111000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00011100,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
         B(00001110,00000000), 0,0,0,0,0,0}}
/*
                  //------- pawn
       {{B(00010000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00001000,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000100,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},
  //----------------------------------------
       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00010000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00001000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
       	 B(00000100,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00010000,00000000),
       	 B(00010000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001000,00000000),
       	 B(00001000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000100,00000000),
         B(00000100,00000000), 0,0,0,0,0,0}},
//=================================================================
       {{B(00110000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00011000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00001100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00110000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00011000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00001100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00110000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00011000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},
  //----------------------------------------
       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00110000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00011000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00110000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00011000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001100,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00110000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00011000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
         B(00001100,00000000), 0,0,0,0,0,0}},
//=================================================================
       {{B(00011000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00001100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000110,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00011000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00001100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000110,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00011000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000110,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},
  //----------------------------------------
       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00011000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001100,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000110,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00011000,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001100,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000110,00000000),
       	 B(00000000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00011000,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00001100,00000000), 0,0,0,0,0,0},

       	{B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
       	 B(00000000,00000000),
         B(00000110,00000000), 0,0,0,0,0,0}}
*/
};


/*
----------------------------------------
{0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,
 0,0,1,0,1,0,0,0,0, 0,0,0,0,0,0,0,
 0,1,1,0,1,1,0,0,0, 0,0,0,0,0,0,0,
 0,0,0,1,0,0,0,0,0, 0,0,0,0,0,0,0,
 0,1,1,0,1,1,0,0,0, 0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
 },
*/
extern unsigned char kingattk_incl_horse[18][BOARD_SIZE-7];

extern unsigned char ATTKAREA[BOARD_SIZE-7];
extern uint64 h_value[10][9][10];   //[piecetype][nFile}[nRank]
extern uint64 h_rside;
#define INF 20480  //1105
const int BAN_VALUE = INF - 100;   //1105  #define BAN_VALUE 1948 //(INFINITY-100) //1900;
//1105 #define WIN_VALUE 1848 //1792 //(INFINITY-256) //1800; 
#define DRAWVALUE 1 //16 //30  //32; // 20;  // 藐视因子，即和棋时返回的分数(取负值)

const unsigned char cur_board[BOARD_SIZE-7]=
    {28, 20, 16, 12, 32, 14, 18, 22, 30,  0,0,0,0,0,0,0,
     0, 0, 0, 0, 0, 0, 0, 0, 0,            0,0,0,0,0,0,0,
     0, 24, 0, 0, 0, 0, 0, 26, 0,          0,0,0,0,0,0,0,
     4, 0, 8, 0, 2, 0, 10, 0, 6,           0,0,0,0,0,0,0,
     0, 0, 0, 0, 0, 0, 0, 0, 0,            0,0,0,0,0,0,0,
     0, 0, 0, 0, 0, 0, 0, 0, 0,            0,0,0,0,0,0,0,
     7, 0,11, 0,3, 0, 9, 0, 5,             0,0,0,0,0,0,0,
     0,27, 0, 0, 0, 0, 0,25, 0,            0,0,0,0,0,0,0,
     0, 0, 0, 0, 0, 0, 0, 0, 0,            0,0,0,0,0,0,0,
     31,23,19, 15, 33, 13,17,21,29
    }; //,        0,0,0,0,0,0,0};
//const char cur_boardsq[34]=
//{-1,-1,31,58,27,62,35,54,29,60,33,56,3,86,5,84,2,87,6,83,1,88,7,82,19,70,25,64,0,89,8,81,4,85};


/*
bool ICCStoPos (char *str, int &from, int &dest)
{

	int sx, sy, dx, dy;
	sx = (str[0] & 0xDF) - 'A';
	sy = '9' - (str[1]);
	dx = (str[3] & 0xDF) - 'A';
	dy = '9' - (str[4]);


	if (sx < 0 || sx > 8 || dx < 0 || dx > 8 ||
		sy < 0 || sy > 9 || dy < 0 || dy > 9)
	{
		return false;
	}

	from = sy * 9 + sx;
	dest = dy * 9 + dx;
   return true;
}
*/
/*
bool com2char (char *move,int from ,int dest)
{	if(from==0 && dest==0) return false;
	if(from<0||from>90||dest<0||dest>90)return false;
	move[0]=from%9+'a';
	move[1]=9-from/9+'0';
	move[2]=dest%9+'a';
	move[3]=9-dest/9+'0';
	move[4]='\0';
	return true;
}
bool char2com(char*move,int &from,int &dest)
{	if(from==0 && dest==0) return false;
	int row=move[0]-'a';
	int col=move[1]-'0';
	from=(9-col)*9+row;
	row=move[2]-'a';
	col=move[3]-'0';
	dest=(9-col)*9+row;
	if(from>=0&&from<=89&&dest>=0&&dest<=89)
	{
		return true;
	}
	return false;
}
*/
/*
void mov2char (char *move,int fromdest)
{
	  MoveStruct t;
	  t.move = fromdest;    
    //if (from==0 && dest==0) return;
    //if (from<0 || from>BOARD_SIZE-7 || dest<0 || dest>BOARD_SIZE-7) return;
    move[0]=nFile(t.from) + 'a';
    move[1]=9-nRank(t.from) + '0';
    move[2]=nFile(t.dest) + 'a';
    move[3]=9-nRank(t.dest) + '0';
    move[4]='\0';
    
}
*/
bool com2char (char *move,int from ,int dest)
{
    if (from==0 && dest==0) return false;
    if (from<0 || from>BOARD_SIZE-7 || dest<0 || dest>BOARD_SIZE-7) return false;
    move[0]=nFile(from) + 'a';
    move[1]=9-nRank(from) + '0';
    move[2]=nFile(dest) + 'a';
    move[3]=9-nRank(dest) + '0';
    move[4]='\0';
    return true;
}
bool char2com(char*move,int &from,int &dest)
{
    if (from==0 && dest==0) return false;
    int row=move[0]-'a';
    int col=move[1]-'0';
    from=((9-col)<<4) + row;
    row=move[2]-'a';
    col=move[3]-'0';
    dest=((9-col)<<4) + row;
    if (from>=0 && from<BOARD_SIZE-7 && dest>=0 && dest<BOARD_SIZE-7)
    {
        return true;
    }
    return false;
}

void Board::Xor(uint64 &m1, const uint64 &m2)
    {
        m1 ^= m2;
    }

void Board::ReSet ()
{
    int i;
    m_side=RED;
    for (i=0;i<34;++i)
        boardsq[i]=SQ_EMPTY;
    for (i=0;i<BOARD_SIZE-7;++i)
    {
        piece[i]=cur_board[i];
        if (piece[i] != 0)
            boardsq[piece[i]]=i;
    }


}
Board::Board()
{
    ReSet();
}

int pawn_index[2]; //={10,11};
int advs_index[2]; //={14,15};
int elep_index[2]; //={18,19};
int hors_index[2]; //={22,23};
int cann_index[2]; //={26,27};
int rook_index[2]; //={30,31};

void Board::Init_index()
{
	for (int i=0; i<2; i++)
	{	pawn_index[i]=10+i;
		advs_index[i]=14+i;
		elep_index[i]=18+i;
		hors_index[i]=22+i;
		cann_index[i]=26+i;
		rook_index[i]=30+i;
	}
}
void Board::Compress_index()
{
  int i, color, sq;
  for (color=2; color--;)
  {
  	// compress pawn boardsq [2]-[11]
  	pawn_index[color]=color; // 2+color-2;
    for (i=2+color; i<=11; i+=2)
    {
    	sq = boardsq[i];
    	//if (sq >=0)
    	if (NOTSQEMPTY(sq))
    	{
    		pawn_index[color] +=2;
    		boardsq[pawn_index[color]] = sq;
    		piece[sq] = pawn_index[color];
    	}
    }
    for (i=pawn_index[color]+2; i<=11; i+=2)
    	boardsq[i] = SQ_EMPTY; // -1


// compress ADVISOR boardsq [12]-[15]

  advs_index[color]=12+color-2;
    for (i=12+color; i<=15; i+=2)
    {
    	sq = boardsq[i];
    	//if (sq >=0)
    	if (NOTSQEMPTY(sq))
    	{advs_index[color] +=2;
    		boardsq[advs_index[color]] = sq;
    		piece[sq] = advs_index[color];

    	}
    }
    for (i=advs_index[color]+2; i<=15; i+=2)
    	boardsq[i] = SQ_EMPTY; // -1


// compress elephant boardsq [16]-[19]

  elep_index[color]=16+color-2;
    for (i=16+color; i<=19; i+=2)
    {
    	sq = boardsq[i];
    	//if (sq >=0)
    	if (NOTSQEMPTY(sq))
    	{elep_index[color] +=2;
    		boardsq[elep_index[color]] = sq;
    		piece[sq] = elep_index[color];

    	}
    }
    for (i=elep_index[color]+2; i<=19; i+=2)
    	boardsq[i] = SQ_EMPTY; // -1

// compress hors boardsq [20]-[23]

  hors_index[color]=20+color-2;
    for (i=20+color; i<=23; i+=2)
    {
    	sq = boardsq[i];
    	//if (sq >=0)
    	if (NOTSQEMPTY(sq))
    	{hors_index[color] +=2;
    		boardsq[hors_index[color]] = sq;
    		piece[sq] = hors_index[color];

    	}
    }
    for (i=hors_index[color]+2; i<=23; i+=2)
    	boardsq[i] = SQ_EMPTY; // -1


// compress cannon boardsq [24]-[27]

  cann_index[color]=24+color-2;
    for (i=24+color; i<=27; i+=2)
    {
    	sq = boardsq[i];
    	//if (sq >=0)
    	if (NOTSQEMPTY(sq))
    	{cann_index[color] +=2;
    		boardsq[cann_index[color]] = sq;
    		piece[sq] = cann_index[color];

    	}
    }
    for (i=cann_index[color]+2; i<=27; i+=2)
    	boardsq[i] = SQ_EMPTY; // -1


// compress rook boardsq [28]-[31]
	rook_index[color]=28+color-2;
    for (i=28+color; i<=31; i+=2)
    {
    	sq = boardsq[i];
    	//if (sq >=0)
    	if (NOTSQEMPTY(sq))
    	{rook_index[color] +=2;
    		boardsq[rook_index[color]] = sq;
    		piece[sq] = rook_index[color];

    	}
    }
    for (i=rook_index[color]+2; i<=31; i+=2)
    	boardsq[i] = SQ_EMPTY; // -1

  }	// end for color
}

//int Board::MakeMove (int from,int dest)
int Board::MakeMove (MoveStruct &move)
{
    int from=move.from;
    int dest=move.dest;
    int capture=piece[dest];
    if (capture) boardsq[capture] = SQ_EMPTY;
    boardsq[piece[from]] = dest;
    piece[dest]=piece[from];
    piece[from]=EMPTY;
    //m_side=oppside(m_side);
    chgside(m_side);
    return capture;
}
void Board::UnMove (int from,int dest,int capture)
{
    //m_side=oppside(m_side);
    chgside(m_side);
    piece[from]=piece[dest];
    piece[dest]=capture;
    if (capture) boardsq[capture] = dest;
    boardsq[piece[from]] = from;
}

//bool Board::LegalMove (int from, int dest)
bool Board::LegalMove (unsigned short Imove)
{
    int i,size;
	long ncapsize;
    MoveTabStruct movetab[96], ncapmovetab[64];

    size=GenCap(&movetab[0], &ncapmovetab[0], ncapsize);
    //size=(m_side ? GenCap<1>(&movetab[0], &ncapmovetab[0], ncapsize)
    //    : GenCap<0>(&movetab[0], &ncapmovetab[0], ncapsize));
    //size=GenCapQS(&movetab[0]);
    for (i=0;i<size;++i)
    {
        if (movetab[i].table.move==Imove)return true;
    }

//
    for (i=0;i<ncapsize;++i)
    {
        if (ncapmovetab[i].table.move==Imove)return true;
    }
//
    size=GenNonCap(&movetab[0], 0);
    for (i=0;i<size;++i)
    {
        if (movetab[i].table.move==Imove)return true;
    }
/*
    size=GenNonCapPBEK(&movetab[0]);
    for (i=0;i<size;++i)
    {
        if (movetab[i].table.move==Imove)return true;
    }
*/
    return false;
}
/*
bool Board::IsEnd()const
{
	//if(m_side==BLACK)
	{	int king_side = B_KING + mside;
		for(int i=0;i<9;++i)
			if(piece[kingpos2[i][m_side]]==king_side)return false;
		return true;
	}
	//
	//else
	//{
	//	for(int i=9;i<18;++i)
	//		if(piece[kingpos2[i]]==R_KING)return false;
	//	return true;
	//}

}
*/

//#define EQUCAP_ROOK   31500
//#define EQUCAP_CANNON 29500
//#define EQUCAP_HORSE 28500
//#define EQUCAP_PAWN   27500

//#define WINCAP_CANNON 32000

extern int PIECE_VALUE_side[46];   //1002 from engine.cpp - chg abs to all +ve 
//extern int PIECE_VALUE[46];

#define t_side (m_side)
//template<int t_side>
int  Board::GenCap(MoveTabStruct *movetab, MoveTabStruct *ncapmovetab, long &ncap)
{
    int nMove=0;
    int DstSq, piecedest; //,xx; //val, k; //,j; //,piecedest_2;
    unsigned char *DstPtr, *EyeLegPtr;
    //SlideMoveStruct *lpsmv;
	ncap=0;

// PAWN
    //for (int bb=10+m_side; bb>=2; bb-=2)
    //for (int bb=10+m_side; bb>pawn_index[m_side]; bb-=2)
    for (int bb=pawn_index[t_side]; bb>=2; bb-=2)
    {
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            DstPtr = g_PawnMoves[SrcSq][t_side];
            DstSq = *DstPtr;
            while (DstSq !=0) //!=255) //>= 0)
            {
            		DstSq--;
                piecedest = piece[DstSq];
                if (piecedest==0)
                {
                	ncapmovetab[ncap].tabentry = (SrcSq <<8) + DstSq;
                	ncapmovetab[ncap].tabval = PAWN - HistValMax;    //1019
                	ncap++;
                }

                else if ( (piecedest&1) !=t_side)  // color not same side
                    {

                      movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                      movetab[nMove].tabval = PIECE_VALU(piecedest) - PAWN + HistValMax;  //1019 for sort root cap bef ncap
                      nMove++;
		    						}

                DstPtr ++;
                DstSq = *DstPtr;
            }
        }

    } // end for bb

  //for (int bb=14+m_side; bb>=12; bb-=2)
		for (int bb=advs_index[t_side]; bb>=12;  bb-=2)
		{
// ADVISOR
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            //DstPtr = g_advelemoves[SrcSq] +3;
            DstPtr = g_KnightMoves[SrcSq] + 9;
            DstSq = *DstPtr;
            while (DstSq != 0)
            {
                piecedest = piece[DstSq];
                if (piecedest==0)
                {
                	ncapmovetab[ncap].tabentry = (SrcSq <<8) + DstSq;
                	ncapmovetab[ncap].tabval = ADVISOR - HistValMax;    //1019
                	ncap++;
                }
                else if ( (piecedest&1) != t_side )  // color not same side
                {
                    movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                      movetab[nMove].tabval = PIECE_VALU(piecedest) - ADVISOR+ HistValMax;  //1019 for sort root cap bef ncap;

                      nMove++;
                }
                DstPtr ++; //--;
                DstSq = *DstPtr;
            }
        }
      } // end bb

// ELEPHANT
		//for (int bb=18+m_side; bb>=16; bb-=2)
		for (int bb=elep_index[t_side]; bb>=16;  bb-=2)
		{
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            //DstPtr = g_advelemoves[SrcSq];
            DstPtr = g_KnightMoves[SrcSq] + 9;
            DstSq = *DstPtr;
            while (DstSq != 0)
            {
                if ( piece[(SrcSq+DstSq) >>1]==0)
                {
                piecedest = piece[DstSq];
                if (piecedest==0)
                {
                	ncapmovetab[ncap].tabentry = (SrcSq <<8) + DstSq;
                	ncapmovetab[ncap].tabval = ELEPHAN - HistValMax;    //1019
                	ncap++;
                }
                else if ( (piecedest&1) != t_side)  // color not same side
                {
                   	//if ( piece[(SrcSq+DstSq) >>1]==0)
                    {
                          movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                      movetab[nMove].tabval = PIECE_VALU(piecedest) - ELEPHAN+ HistValMax;  //1019 for sort root cap bef ncap;
                      nMove++;
                    }
                }
              }
                DstPtr ++;
                DstSq = *DstPtr;
            }
        }
} // end bb

// HORSE
//for (int bb=22+m_side; bb>=20; bb-=2)
for (int bb=hors_index[t_side]; bb>=20;  bb-=2)
{
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            DstPtr = g_KnightMoves[SrcSq];
            EyeLegPtr = g_HorseLegs[SrcSq];
            DstSq = *DstPtr;
            while (DstSq !=0) //>=0) //!=255) // >= 0)
            {
            	if (piece[*EyeLegPtr]==0)
            	{
            		DstSq--;
                piecedest = piece[DstSq];
                if (piecedest==0)
                {
                	ncapmovetab[ncap].tabentry = (SrcSq <<8) + DstSq;
                	ncapmovetab[ncap].tabval = HORSE - HistValMax;    //1019
                	ncap++;
                }
                else if ((piecedest&1) != t_side ) // color not same side
                {
									//if (piece[*EyeLegPtr]==0)
									{
                    movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                      movetab[nMove].tabval = PIECE_VALU(piecedest) - HORSE+ HistValMax;  //1019 for sort root cap bef ncap;
                      nMove++;
                  }
                }
              }
              DstPtr ++;
              DstSq = *DstPtr;
              EyeLegPtr ++;
            }
        }
		} // end for bb

//GenCapCannRook(movetab, nMove);
	SlideMoveStruct *lpsmv;

	//for (int bb=26+m_side; bb>=24; bb-=2)
//for (int bb=cann_index[t_side]; bb>=24;  bb-=2)
for (int bb=rook_index[t_side]; bb>=24; bb-=2)
{
        // 6. 生成炮的着法
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            int y = nRank(SrcSq); // / 16;
            int x = nFile(SrcSq); //SrcSq - nDisp; //nFile(SrcSq); // % 16;

            int nDisp = (y<<4);  //(y<<3) + y; // * 9; //16;
            //nDisp[0] = x;
            lpsmv = PreGen.smvRankMoveTab[x ] + wBitRanks[y];
            //lpsmv[0] = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
            for (int k=2; k--;)
            {
            //for (int n=2; n--;)
            //{
                //DstSq = lpsmv->CannonCap[1]; // + nDisp;

                DstSq = (bb<28 ? lpsmv->CannonCap[1] : lpsmv->RookCap[1]);    //1019 gen both cannon and rook cap
                //if ((DstSq) !=0)
                if (DstSq != SrcSq)
                {
                	DstSq +=nDisp; //-1;
                    if ( (piece[DstSq]&1) != t_side)
                    {
                      movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                      movetab[nMove].tabval = PIECE_VALU(piece[DstSq]) - bb+ HistValMax;  //1019 for sort root cap bef ncap; //CANNON;
                      nMove++;
                    }
                }
                DstSq = (bb<28 ? lpsmv->CannonCap[0] : lpsmv->RookCap[0]);
                //if ((DstSq) !=0)
                if (DstSq != SrcSq)
                {
                	DstSq +=nDisp; //-1;
                    if ( (piece[DstSq]&1) != t_side)
                    {
                      movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                      movetab[nMove].tabval = PIECE_VALU(piece[DstSq]) - bb+ HistValMax;  //1019 for sort root cap bef ncap; //CANNON;
                      nMove++;
                    }
                }

            //} // end for n

						if (k>0) {
            nDisp = x;
            lpsmv = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
          }
        } // end k

        } // end for SrcSq
    } // end for bb

// KING
    //if (NOTSQEMPTY(boardsq[32+m_side]))
    {
        int SrcSq = boardsq[32+t_side];
        DstPtr = g_PawnMoves[SrcSq][t_side] +3;
        DstSq = *DstPtr;
        while (DstSq !=0) //!= 0)
        {
            piecedest = piece[DstSq];
            if (piecedest==0)
                {
                	ncapmovetab[ncap].tabentry = (SrcSq <<8) + DstSq;
                	ncapmovetab[ncap].tabval = 0 - HistValMax;    //1019
                	ncap++;
                }
            else if (  (piecedest&1) != t_side)  // color not same side
            {
                movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                movetab[nMove].tabval = PIECE_VALU(piecedest) - 32+ HistValMax;  //1019 for sort root cap bef ncap; //KING;
                nMove++;
            }
            DstPtr --; //++;
            DstSq = *DstPtr;
        }
    }

    //return (int)(tabptr - movetab) ; // no need to divide sizeof, strange behaviour of pointer!! / sizeof(*tabptr) ;
    return nMove;
}

template<int q_side>
int  Board::GenCapQS(MoveTabStruct *movetab)
{
    int nMove=0;
    int DstSq, piecedest; //,xx; //val, k; //,j; //,piecedest_2;
    unsigned char *DstPtr, *EyeLegPtr;
    //SlideMoveStruct *lpsmv;
	//ncap=0;

// PAWN
    //for (int bb=10+m_side; bb>=2; bb-=2)
    //for (int bb=10+m_side; bb>pawn_index[m_side]; bb-=2)
    for (int bb=pawn_index[q_side]; bb>=2; bb-=2)
    {
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            DstPtr = g_PawnMoves[SrcSq][q_side];
            DstSq = *DstPtr;
            while (DstSq !=0) //!=255) //>= 0)
            {
            		DstSq--;
                piecedest = piece[DstSq];
                if (piecedest==0)
                {
                	//ncapmovetab[ncap].tabentry = (SrcSq <<8) + DstSq;
                	//ncap++;
                }

                else if ( (piecedest&1) !=q_side)  // color not same side
                    {
                      movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                      movetab[nMove].tabval = PIECE_VALU(piecedest) - PAWN;
                      nMove++;
		    						}
                DstPtr ++;
                DstSq = *DstPtr;
            }
        }
    } // end for bb

  //for (int bb=14+m_side; bb>=12; bb-=2)
		for (int bb=advs_index[q_side]; bb>=12;  bb-=2)
		{
// ADVISOR
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            //DstPtr = g_advelemoves[SrcSq] +3;
            DstPtr = g_KnightMoves[SrcSq] + 9;
            DstSq = *DstPtr;
            while (DstSq != 0)
            {
                piecedest = piece[DstSq];
                if (piecedest==0)
                {
                	//ncapmovetab[ncap].tabentry = (SrcSq <<8) + DstSq;
                	//ncap++;
                }
                else if ( (piecedest&1) != q_side )  // color not same side
                {
                    movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                      movetab[nMove].tabval = PIECE_VALU(piecedest) - ADVISOR;
                      nMove++;
                }
                DstPtr ++; //--; //++;
                DstSq = *DstPtr;
            }
        }
      } // end bb

// ELEPHANT
		//for (int bb=18+m_side; bb>=16; bb-=2)
		for (int bb=elep_index[q_side]; bb>=16;  bb-=2)
		{
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            //DstPtr = g_advelemoves[SrcSq];
            DstPtr = g_KnightMoves[SrcSq] + 9;
            DstSq = *DstPtr;
            while (DstSq != 0)
            {
                if ( piece[(SrcSq+DstSq) >>1]==0)
                {
                piecedest = piece[DstSq];
                if (piecedest==0)
                {
                	//ncapmovetab[ncap].tabentry = (SrcSq <<8) + DstSq;
                	//ncap++;
                }
                else if ( (piecedest&1) != q_side)  // color not same side
                {
                   	//if ( piece[(SrcSq+DstSq) >>1]==0)
                    {
                          movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                      movetab[nMove].tabval = PIECE_VALU(piecedest) - ELEPHAN;
                      nMove++;
                    }
                }
              }
                DstPtr ++;
                DstSq = *DstPtr;
            }
        }
} // end bb

// HORSE
//for (int bb=22+m_side; bb>=20; bb-=2)
for (int bb=hors_index[q_side]; bb>=20;  bb-=2)
{
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            DstPtr = g_KnightMoves[SrcSq];
            EyeLegPtr = g_HorseLegs[SrcSq];
            DstSq = *DstPtr;
            while (DstSq !=0) //>=0) //!=255) // >= 0)
            {
            	if (piece[*EyeLegPtr]==0)
            	{
            		DstSq--;
                piecedest = piece[DstSq];
                if (piecedest==0)
                {
                	//ncapmovetab[ncap].tabentry = (SrcSq <<8) + DstSq;
                	//ncap++;
                }
                else if ((piecedest&1) != q_side ) // color not same side
                {
									//if (piece[*EyeLegPtr]==0)
									{
                    movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                      movetab[nMove].tabval = PIECE_VALU(piecedest) - HORSE;
                      nMove++;
                  }
                }
              }
              DstPtr ++;
              DstSq = *DstPtr;
              EyeLegPtr ++;
            }
        }
		} // end for bb

//GenCapCannRook(movetab, nMove);
	SlideMoveStruct *lpsmv;

for (int bb=rook_index[q_side]; bb>=24; bb-=2)
{
        // 6. 生成炮的着法
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            int y = nRank(SrcSq); // / 16;
            int x = nFile(SrcSq); //SrcSq - nDisp; //nFile(SrcSq); // % 16;

            int nDisp = (y<<4);  //(y<<3) + y; // * 9; //16;
            //nDisp[0] = x;
            lpsmv = PreGen.smvRankMoveTab[x ] + wBitRanks[y];
            //lpsmv[0] = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
            for (int k=2; k--;)
            {
            	//for (int n=2; n--;)
            //{
                //DstSq = lpsmv->CannonCap[1]; // + nDisp;
                DstSq = (bb<28 ? lpsmv->CannonCap[1] : lpsmv->RookCap[1]);
                //if ((DstSq) !=0)
                if (DstSq != SrcSq)
                {
                	DstSq +=nDisp; //-1;
                    if ( (piece[DstSq]&1) != q_side)
                    {
                      movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                      movetab[nMove].tabval = PIECE_VALU(piece[DstSq]) - bb; //CANNON;
                      nMove++;
                    }
                }
                DstSq = (bb<28 ? lpsmv->CannonCap[0] : lpsmv->RookCap[0]);
                //if ((DstSq) !=0)
                if (DstSq != SrcSq)
                {
                	DstSq +=nDisp; //-1;
                    if ( (piece[DstSq]&1) != q_side)
                    {
                      movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                      movetab[nMove].tabval = PIECE_VALU(piece[DstSq]) - bb; //CANNON;
                      nMove++;
                    }
                }
            //} // end for n
            if (k>0) {
            nDisp = x;
            lpsmv = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
          }
        } // end k

        } // end for SrcSq
    } // end for bb


// KING
    //if (NOTSQEMPTY(boardsq[32+m_side]))
    {
        int SrcSq = boardsq[32+q_side];
        DstPtr = g_PawnMoves[SrcSq][q_side] +3;
        DstSq = *DstPtr;
        while (DstSq !=0) //!= 0)
        {
            piecedest = piece[DstSq];
            if (piecedest==0)
                {
                	//ncapmovetab[ncap].tabentry = (SrcSq <<8) + DstSq;
                	//ncap++;
                }
            else if (  (piecedest&1) != q_side)  // color not same side
            {
                movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                movetab[nMove].tabval = PIECE_VALU(piecedest) - 32; //KING;
                nMove++;
            }
            DstPtr --; //++;
            DstSq = *DstPtr;
        }
    }

    //return (int)(tabptr - movetab) ; // no need to divide sizeof, strange behaviour of pointer!! / sizeof(*tabptr) ;
    return nMove;
}
template int  Board::GenCapQS<0>(MoveTabStruct *movetab);
template int  Board::GenCapQS<1>(MoveTabStruct *movetab);

static const int shiftx[16]={0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004,0x0002,0x0001};
static const unsigned short shiftFile[BOARD_SIZE-7]={0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004,0x0002,0x0001,
0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004,0x0002,0x0001,
0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004,0x0002,0x0001,
0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004,0x0002,0x0001,
0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004,0x0002,0x0001,
0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004,0x0002,0x0001,
0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004,0x0002,0x0001,
0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004,0x0002,0x0001,
0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004,0x0002,0x0001,
0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0400, 0x0200, 0x0100, 0x0080}; //, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004,0x0002,0x0001};

//int Board::GenChkEvasCap(MoveTabStruct movetab[], int incheck)	//1=rook/c/p File, 2=R Rank, 3=L rank, 4=horse chk
int Board::GenChkEvasCap(MoveTabStruct *movetab, int chkidx) //, MoveTabStruct *ncapmovetab, int *ncapsize )
{
    int nMove=0;
    int DstSq, wchkidx, x, y, nDisp; //piecedest; //, xx;
    unsigned char *DstPtr, *EyeLegPtr;

    //MoveTabStruct *tabptr; //, *ncaptabptr;
    //tabptr = movetab;

    SlideMoveStruct *lpsmv;
    int kingpos = boardsq[32+m_side];
    int kingidx=kingindex[kingpos];
		wchkidx = (chkidx &15) - 1;

	//for (bb=2+m_side; bb>=0; bb-=2)

        // ADVISOR   incl noncap
    //for (int bb=14+m_side; bb>=12; bb-=2)
		for (int bb=advs_index[m_side];  bb>=12; bb-=2)
		{
        //SrcSq = boardsq[bb];
        //if (SrcSq >=0 )
        //	if (NOTSQEMPTY(SrcSq))
        //{
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            //DstPtr = g_advelemoves[SrcSq] +3;
            DstPtr = g_KnightMoves[SrcSq] + 9;
            DstSq = *DstPtr;
            while (DstSq != 0)
            {
                int piecedest = piece[DstSq];
                if ( piecedest==0
                	|| ( ((piecedest&1) !=m_side)  && (chkidx &16)==0  ) )  // empty or color not same side

                {

                    //if (kingevas[chkidx][kingidx][SrcSq] || kingevas[chkidx][kingidx][DstSq]) {
                    if (
                    	(kingevas[wchkidx][kingidx][nRank(DstSq)] & (shiftFile[DstSq]))
                    || (kingevas[wchkidx][kingidx][nRank(SrcSq)] & (shiftFile[SrcSq]))
                    )
                    {
                    	//if (MoveInChk(SrcSq, DstSq, piecedest) ==0)
                    	{

                        //TABMOVE(SrcSq, DstSq);
                        //tabptr->tabval = (piecedest) - ADVISOR;
                        //tabptr++;
                        movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                            movetab[nMove].tabval = (piecedest) - ADVISOR + HistValMax;  //1019 cap evasion bef ncap
                            nMove++;
                      }
                    }
                }
                DstPtr ++; //--; //++;
                DstSq = *DstPtr;
            }
        }
      }	// end bb

 // ELEPHANT   incl noncap
//for (int bb=18+m_side; bb>=16; bb-=2)
for (int bb=elep_index[m_side]; bb>=16;  bb-=2)
{
        //SrcSq = boardsq[bb];
        //if (SrcSq >=0 )
        //	if (NOTSQEMPTY(SrcSq))
        //{
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            //DstPtr = g_advelemoves[SrcSq];
            DstPtr = g_KnightMoves[SrcSq] + 9;
            DstSq = *DstPtr;
            while (DstSq != 0)
            {
                int piecedest = piece[DstSq];
                if ( piecedest==0
                	|| ( ((piecedest&1) !=m_side) && (chkidx &16)==0  )  // empty or color not same side
                	 )
                	 if ( piece[(SrcSq+DstSq) >>1]==0)
                {

                    //if (kingevas[chkidx][kingidx][SrcSq] || kingevas[chkidx][kingidx][DstSq]) {
                    if (
                    	(kingevas[wchkidx][kingidx][nRank(DstSq)] & (shiftFile[DstSq]))
                    || (kingevas[wchkidx][kingidx][nRank(SrcSq)] & (shiftFile[SrcSq]))
                    ) {
										//if (MoveInChk(SrcSq, DstSq, piecedest) ==0)
                    	{

                        //TABMOVE(SrcSq, DstSq);
                        //tabptr->tabval = (piecedest) - ELEPHAN;
                        //tabptr++;
                        movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                            movetab[nMove].tabval = (piecedest) - ELEPHAN + HistValMax;  //1019 cap evasion bef ncap;
                            nMove++;
                      }
                    }
                }
                DstPtr ++;
                DstSq = *DstPtr;
            }
        }
} // end bb


//HORSE - cap only
//for (int bb=22+m_side; bb>=20; bb-=2)
for (int bb=hors_index[m_side];  bb>=20; bb-=2)
{
        //SrcSq = boardsq[bb];
        //if (SrcSq >=0 )
        //	if (NOTSQEMPTY(SrcSq))
        //{
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            DstPtr = g_KnightMoves[SrcSq];
            EyeLegPtr = g_HorseLegs[SrcSq];
            DstSq = *DstPtr;
            while (DstSq !=0) //>=0) //!=255) //>= 0)
            {
                if (piece[*EyeLegPtr] == 0)
                {		DstSq--;
                    //piecedest = piece[DstSq];
                    if (   piece[DstSq] &&
                     (  ((piece[DstSq]&1) !=m_side) && (chkidx &16)==0 ) ) // empty or color not same side
                    {
                        //if (kingevas[chkidx][kingidx][SrcSq] || kingevas[chkidx][kingidx][DstSq])				{
                        if (
                        	(kingevas[wchkidx][kingidx][nRank(DstSq)] & (shiftFile[DstSq]))
                        || (kingevas[wchkidx][kingidx][nRank(SrcSq)] & (shiftFile[SrcSq]))

                        )
                         {
                            //if (MoveInChk(SrcSq, DstSq, piecedest) ==0)
                    	{

                            //TABMOVE(SrcSq, DstSq);
                            //tabptr->tabval = -HORSE;
                            //tabptr++;
                            movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                            movetab[nMove].tabval = -HORSE + HistValMax;  //1019 cap evasion bef ncap;
                            nMove++;
                          }
                        }
                    }
                }

                DstPtr ++;
                DstSq = *DstPtr;
                EyeLegPtr ++;
            }
        }
} // end bb

// gen evas cannon/rook cap only if single incheck
if ((chkidx &16)==0 )
{
//CANNON
        // 6. 生成炮的着法
//for (int bb=26+m_side; bb>=24; bb-=2)
//for (int bb=cann_index[m_side]; bb>=24;  bb-=2)
for (int bb=rook_index[m_side]; bb>=24; bb-=2)
{
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
        	  y = nRank(SrcSq); // / 16;
        	  x = nFile(SrcSq); //SrcSq - nDisp; // // % 16;

            nDisp = (y<<4);  //(y<<3) + y; // * 9; //16;
            //nDisp[0] = x;
            lpsmv = PreGen.smvRankMoveTab[x ] + wBitRanks[y];
            //lpsmv[0] = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
            for (int k=2; k--;) {
             //for (int n=2; n--;)
            //{
                //DstSq = (bb<28 ? lpsmv->CannonCap[n] : lpsmv->RookCap[n]);
                DstSq = (bb<28 ? lpsmv->CannonCap[1] : lpsmv->RookCap[1]);
                //if ((DstSq) !=0)
                if (DstSq != SrcSq)
                {
                	DstSq +=nDisp; //-1;
                  if ( ((piece[DstSq]&1)!=m_side) )
                  {
                      if ( (kingevas[wchkidx][kingidx][nRank(DstSq)] & (shiftFile[DstSq]))
                        || (kingevas[wchkidx][kingidx][y] & (shiftx[x])) )
                    	{
                            movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                            movetab[nMove].tabval = -bb + HistValMax;  //1019 cap evasion bef ncap; //-CANNON;
                            nMove++;
                      }
                  }
                }
                DstSq = (bb<28 ? lpsmv->CannonCap[0] : lpsmv->RookCap[0]);
                //if ((DstSq) !=0)
                if (DstSq != SrcSq)
                {
                	DstSq +=nDisp; //-1;
                  if ( ((piece[DstSq]&1)!=m_side) )
                  {
                      if ( (kingevas[wchkidx][kingidx][nRank(DstSq)] & (shiftFile[DstSq]))
                        || (kingevas[wchkidx][kingidx][y] & (shiftx[x])) )
                    	{
                            movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                            movetab[nMove].tabval = -bb + HistValMax;  //1019 cap evasion bef ncap; //-CANNON;
                            nMove++;
                      }
                  }
                }
            //} //end for n

					if(k>0) {
            nDisp = x;
            lpsmv = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
          }
        } // end k

        } // end for SrcSq
} // end bb

/*
//ROOK
        // 5. 生成车的着法
//for (int bb=30+m_side; bb>=28; bb-=2)
for (int bb=rook_index[m_side];  bb>=28; bb-=2)
{
        //SrcSq = boardsq[bb];
        //if (SrcSq >=0 )
        //	if (NOTSQEMPTY(SrcSq))
        //	{
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
        		y = nRank(SrcSq); // / 16;
        		x = nFile(SrcSq); //SrcSq - nDisp; //nFile(SrcSq); // % 16;

            nDisp = (y<<4);  //(y<<3) + y; // * 9; //16;
            //nDisp[0] = x;
            lpsmv = PreGen.smvRankMoveTab[x ] + wBitRanks[y];
            //lpsmv[0] = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
            for (int k=2; k--;) {

            for (int n=2; n--;)
            {
                DstSq = lpsmv->RookCap[n]; // + nDisp;
                if ((DstSq) !=0) {
                	DstSq +=nDisp-1;
                    if ( (piece[DstSq]&1)!=m_side)
                    {
                        //if (kingevas[chkidx][kingidx][DstSq] || kingevas[chkidx][kingidx][SrcSq]) {
                       // if ((kingevas[chkidx][kingidx][nRank(DstSq)] & (0x8000>>(nFile(DstSq))))
                       //  || (kingevas[chkidx][kingidx][y] & (0x8000>>(x))))
                        if (
                        	(kingevas[wchkidx][kingidx][nRank(DstSq)] & shiftFile[DstSq])
                         || (kingevas[wchkidx][kingidx][y] & shiftx[x])
                         )
                         {
                            movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                            movetab[nMove].tabval = -ROOK;
                            nMove++;
                          }
                    }
                }
            } // end for n

						if (k>0) {
            nDisp = x;
            lpsmv = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
          }
        } // end k

        } // end for SrcSq


    } // end for bb
    */
} // end if chkidx

//KING   incl noncap

    //if (SrcSq >=0 )
    {
        //DstPtr4 = g_KingMoves[SrcSq];
        DstPtr = g_PawnMoves[kingpos][m_side] +3;
        DstSq = *DstPtr;
        while (DstSq !=0) //!= 0)
        {	//DstSq--;
            //piecedest = piece[DstSq];
            if (piece[DstSq]==0 || ( ((piece[DstSq]&1) !=m_side)) ) // empty or color not same side
            {
								//if (MoveInChk(kingpos, DstSq, piecedest) ==0)
               	{

                //TABMOVE(kingpos, DstSq);
                //tabptr->tabval = -KING; //(piecedest) - KING;
                //tabptr++;
                movetab[nMove].tabentry = (kingpos <<8) + DstSq;
                movetab[nMove].tabval = -32 + HistValMax;  //1019 cap evasion bef ncap; //-KING;
                nMove++;
							}

            }
            DstPtr --; //++;
            DstSq = *DstPtr;
        }
    }




    //return (int)(tabptr - movetab) ; // no need to divide sizeof, strange behaviour of pointer!! / sizeof(*tabptr) ;
    return nMove;
}




static const int noncapstep[2][2] = {{-16, 16}, {-1, 1}};
//only gen rook/cannon noncap and pawn for chkevasion
//int Board::GenChkEvasNCap(MoveTabStruct movetab[], int incheck)
int Board::GenChkEvasNCap(MoveTabStruct *movetab, int chkidx)
{
    int nMove=0;
    int DstSq, wchkidx, x, y,  nDisp; //k, n, nStep; //, piecedest;
    wchkidx = (chkidx &15) - 1;
    unsigned char *DstPtr, *EyeLegPtr;
		SlideMoveStruct *lpsmv;
    //MoveTabStruct *tabptr;
    //tabptr = movetab;

    int kingidx=kingindex[boardsq[32+m_side]];
    //int chkidx = incheck - 1;
    int pieceidx;
//for (int bb=30+m_side; bb>=24; bb-=2)
for (int bb=rook_index[m_side];  bb>=24; bb-=2)
    {
//cannon and rook nocapture moves are the same

        //SrcSq = boardsq[bb];
        //if (SrcSq >=0 )
        //	if (NOTSQEMPTY(SrcSq))
        //{
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            pieceidx = PIECE_IDX(bb);
        	int srcchk = (kingevas[wchkidx][kingidx][nRank(SrcSq)] & (shiftFile[SrcSq]));

						y = nRank(SrcSq); // / 16;
						x = nFile(SrcSq); //SrcSq - nDisp; //nFile(SrcSq); // % 16;

            nDisp = (y<<4);  //(y<<3) + y; // * 9; //16;
            //nDisp[0] = x;
            lpsmv = PreGen.smvRankMoveTab[x ] + wBitRanks[y];
            //lpsmv[0] = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
            for (int k=2; k--;)
            {
            int nStep=k-(k*16)+16;
            //	 int nStep = noncapstep[k][n];
            //for (int n=2; n--;)
            //{
              DstSq = lpsmv->NonCap[1]; // + nDisp;
              //if ((DstSq) !=0)
              if (DstSq != SrcSq)
              {	 DstSq +=nDisp; //-1;

                while ((DstSq) != SrcSq)
                {
                	if ( srcchk || (kingevas[wchkidx][kingidx][nRank(DstSq)] & (shiftFile[DstSq])) )
                  {
                  	movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                    //movetab[nMove].tabval = (m_his_table[DstSq][PIECE_IDX16(bb)].HistVal);
                    movetab[nMove].tabval = his_table(pieceidx, DstSq);
                    nMove++;
                  }
        					DstSq += nStep;
      					}
              }
              DstSq = lpsmv->NonCap[0]; // + nDisp;
              //if ((DstSq) !=0)
              if (DstSq != SrcSq)
              {	 DstSq +=nDisp; //-1;

                while ((DstSq) != SrcSq)
                {
                	if ( srcchk || (kingevas[wchkidx][kingidx][nRank(DstSq)] & (shiftFile[DstSq])) )
                  {
                  	movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                    //movetab[nMove].tabval = (m_his_table[DstSq][PIECE_IDX16(bb)].HistVal);
                    movetab[nMove].tabval = his_table(pieceidx, DstSq);
                    nMove++;
                  }
        					DstSq -= nStep;
      					}
              }
            //} //end for n

            //gen down and up move
            if (k>0) {
            nDisp = x;
            lpsmv = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
          }
        } // end k

        } // end for SrcSq
 } // end for bb

//HORSE - noncap only
//for (int bb=22+m_side; bb>=20; bb-=2)
for (int bb=hors_index[m_side];  bb>=20; bb-=2)
{
        //SrcSq = boardsq[bb];
        //if (SrcSq >=0 )
        //	if (NOTSQEMPTY(SrcSq))
        //{
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            pieceidx = PIECE_IDX(bb);
            DstPtr = g_KnightMoves[SrcSq];
            EyeLegPtr = g_HorseLegs[SrcSq];
            DstSq = *DstPtr;
            while (DstSq !=0) //>=0) //!=255) //>= 0)
            {
                if (piece[*EyeLegPtr] == 0)
                {		DstSq--;

                    if (piece[DstSq] ==0)

                    {
                        //if (kingevas[chkidx][kingidx][SrcSq] || kingevas[chkidx][kingidx][DstSq])				{
                        if (
                        	(kingevas[wchkidx][kingidx][nRank(DstSq)] & (shiftFile[DstSq]))
                        || (kingevas[wchkidx][kingidx][nRank(SrcSq)] & (shiftFile[SrcSq]))

                        )
                         {
                            //if (MoveInChk(SrcSq, DstSq, piecedest) ==0)
                    	{

                        movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                        //movetab[nMove].tabval = (m_his_table[DstSq][PIECE_IDX16(bb)].HistVal);
                        movetab[nMove].tabval = his_table(pieceidx, DstSq);
                        nMove++;
                          }
                        }
                    }
                }

                DstPtr ++;
                DstSq = *DstPtr;
                EyeLegPtr ++;
            }
        }
} // end bb


// PAWN
    //for (bb=10+m_side; bb>=2; bb-=2)
    //for (int bb=10+m_side; bb>pawn_index[m_side]; bb-=2)
    for (int bb=pawn_index[m_side]; bb>=2; bb-=2)
    {
        //SrcSq = boardsq[bb];
        //if (SrcSq >=0) // != SQ_EMPTY
        //	if (NOTSQEMPTY(SrcSq))
        //{
        	if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            pieceidx = PIECE_IDX(bb);
            DstPtr = g_PawnMoves[SrcSq][m_side];
            DstSq = *DstPtr;
            while (DstSq !=0) //!=255) // >= 0)
            { 	DstSq--;
                //if (piece[DstSq]==0  ) // not gen capture for doubleck
                if (piece[DstSq]==0 || (( (piece[DstSq]&1) !=m_side) && (chkidx &16)==0 )) // empty or color not same side
                {
                    //if (kingevas[chkidx][kingidx][SrcSq] || kingevas[chkidx][kingidx][DstSq]) {
                    if (
                    	(kingevas[wchkidx][kingidx][nRank(DstSq)] & (shiftFile[DstSq]))
                    || (kingevas[wchkidx][kingidx][nRank(SrcSq)] & (shiftFile[SrcSq]))
                    )
                    {

                        movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                        //movetab[nMove].tabval = (m_his_table[DstSq][PIECE_IDX16(bb)].HistVal);
                        movetab[nMove].tabval = his_table(pieceidx, DstSq);
                        nMove++;
                    }
                }
                DstPtr ++;
                DstSq = *DstPtr;
            }
        }
    } // end bb


    //return (int)(tabptr - movetab) ; // no need to divide sizeof, strange behaviour of pointer!! / sizeof(*tabptr) ;
		return nMove;
}


int Board::GenNonCap(MoveTabStruct *movetab, int depth)
{
    //static const char noncapstep[2][2] = {-16, 16, -1, 1};
    int nMove=0;
    int DstSq, piecefromidx, x, y, nDisp; //nStep; //, n, k; //, nStep;  //fcannon, piecedest;
    //unsigned char *DstPtr; //, *EyeLegPtr;
    SlideMoveStruct *lpsmv;


    //MoveTabStruct *tabptr;
    //tabptr = movetab;

    int pointtablefrom; //, xx;


//for (int bb=30+m_side; bb>=24; bb-=2)
for (int bb=rook_index[m_side];  bb>=24; bb-=2)
{
//cannon and rook nocapture moves are the same

        //SrcSq = boardsq[bb];
        //SrcSq = boardsq[i+28];
        //if (SrcSq >=0 )
        //	if (NOTSQEMPTY(SrcSq))
        //{	//piecefrom = piece[SrcSq];
            //piecefrom = (bb) &29;
            if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            piecefromidx = PIECE_IDX(bb);


						y = nRank(SrcSq); // / 16;
						x = nFile(SrcSq); //SrcSq - nDisp; //nFile(SrcSq); // % 16;
            //pointtablefrom = abs(pointtable[piecefromidx][nRank(SrcSq)][nFile(SrcSq)]);
            pointtablefrom = abs_pointtable[piecefromidx][y][x];
            nDisp = (y<<4);  //(y<<3) + y; // * 9; //16;
            //nDisp[0] = x;
            lpsmv = PreGen.smvRankMoveTab[x ] + wBitRanks[y];
            //lpsmv[0] = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
            for (int k=2; k--;) {
            int nStep=k-(k*16)+16;
            //int nStep = noncapstep[k][n];
            //for (int n=2; n--;)
            //{
              DstSq = lpsmv->NonCap[1]; // + nDisp;
              //if ((DstSq) !=0)
              if (DstSq != SrcSq)
              {
                	DstSq +=nDisp; //-1;
            	  //int nStep = (n<<(5-(k<<2))) - (1<<(4-(k<<2)));
                while ((DstSq) != SrcSq)
                {
                        movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                        //movetab[nMove].tabval = (m_his_table[piecefromidx][nFile(DstSq)][nRank(DstSq)].HistVal)
                        // Ensure history has always highest priority
                        //int hs = his_table(piecefromidx, DstSq);
                        //if (hs > 0)
                        //	hs += 512;
                        // if attk opp king (potential checking) sort to front
                        //hs +=	kingattk_incl_horse[kingindex[boardsq[33-m_side]]][DstSq]<<13; //+8192	
                        movetab[nMove].tabval = 
                        	 (abs_pointtable[piecefromidx][nRank(DstSq)][nFile(DstSq)]
                          - pointtablefrom) ;
                        if (depth > 1)  
                           movetab[nMove].tabval += his_table(piecefromidx, DstSq); 
                        nMove++;
        								DstSq += nStep;
      					}
               }
               DstSq = lpsmv->NonCap[0]; // + nDisp;
              //if ((DstSq) !=0)
              if (DstSq != SrcSq)
              {
                	DstSq +=nDisp; //-1;
            	  //int nStep = (n<<(5-(k<<2))) - (1<<(4-(k<<2)));
                while ((DstSq) != SrcSq)
                {
                        movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                        //movetab[nMove].tabval = his_table(piecefromidx, DstSq)
                        // Ensure history has always highest priority
                        //int hs = his_table(piecefromidx, DstSq);
                        //if (hs > 0)
                        //	hs += 512;
                        movetab[nMove].tabval = 
                           (abs_pointtable[piecefromidx][nRank(DstSq)][nFile(DstSq)]
                          - pointtablefrom) ;
                        if (depth > 1)  
                           movetab[nMove].tabval += his_table(piecefromidx, DstSq);   
                        nMove++;
        								DstSq -= nStep;
      					}
               }
            //} // end for n

            //gen down and up move
            if (k>0) {
            nDisp = x;
            lpsmv = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
          }
        } // end k
       } // end for SrcSq

} // end bb


return nMove;
}

//static const int BASERANK[2] = {0, 9};
//static const int THIRDRANK[2] = {2, 7};
//  static const int CENTRKING[2] = {36, 116};
template<int singlechk>
int Board::IsInCheck(int side) //, int singlechk)
{
//    2,3, 4,5,6,7, 8,9,10,11, 12,13,14,15, 16,17,18,19, 20,21,22,23, 24,25,26,27, 28,29,30,31, 32,33
//    p p  p p p p  p p p  p   b  b  b  b   e  e  e  e   n  n  n  n   c  c  c  c   r  r  r  r   k  k

// if not chk, return 0
// if rook/cannon/p chk, File return 1
// if rook/cannon/p chk, Rank return 2 (if DstSq > kingpos)  for kingevas in GenChkEvasion()
// if rook/cannon/p chk, Rank return 3 (if DstSq < kingpos)
// if horse_chk return 4


    // 将军判断包括以下几部分内容：
    int bb,kingpos,  x, y; //piecey,//, xx;
    SlideMaskStruct *lpsmsRankMask, *lpsmsFileMask;
//
    // 1. 判断帅(将)是否在棋盘上
    //sqSrc = this->ucsqPieces[48 - nSideTag];
    kingpos = boardsq[32+side];
    //if (kingpos < 0)
    if (!(NOTSQEMPTY(kingpos)))
    {
      return 0; //cannot be 1 ->error; //0;
    }
//2.获得帅(将)所在格子的位行和位列

    y = nRank(kingpos); // / 9;
    x = nFile(kingpos); //kingpos - ((y<<3) + y); //(y * 9); //nFile(kingpos); // % 9;
    lpsmsRankMask = PreGen.smsRankMaskTab[x ] + wBitRanks[y];
    lpsmsFileMask = PreGen.smsFileMaskTab[y ] + wBitFiles[x];
    // 3. 判断是否将帅对脸
    //
    //sqDst = boardsq[33-side];
    //if (sqDst >= 0)
    if (NOTSQEMPTY(boardsq[33-side]))
    	{
    	int	sqDst = boardsq[33-side];
    	if (x == nFile(sqDst) && (lpsmsFileMask->RookCap & PreGen.wBitFileMask[sqDst]) != 0) {
        return 1;
    	}
		}

		// 6. 判断是否被炮将军

    //for (bb=27-side; bb>=24; bb-=2)
    for (bb=cann_index[oppside(side)]; bb>=24; bb-=2)
		{
    //sqDst = boardsq[bb];
    //if (sqDst >=0 )
    	//if (NOTSQEMPTY(sqDst))
    	// {
    	if (NOTSQEMPTY(boardsq[bb]))
    	{
    		int sqDst = boardsq[bb];
        if (x == nFile(sqDst)) {
            if ((lpsmsFileMask->CannonCap & PreGen.wBitFileMask[sqDst]) != 0)
            {
            	if (singlechk==0)
            	// 6. 判断是否被车将军
    						//for (int bbc=31-side; bbc>=28; bbc-=2)
    						for (int bbc=rook_index[oppside(side)];  bbc>=28; bbc-=2)
								{
    						//sqDstc = boardsq[bbc];
    						//if (sqDstc >=0 )
    						//	if (NOTSQEMPTY(sqDstc))
    						//	{
    								if (NOTSQEMPTY(boardsq[bbc]))
    	{
    		int sqDstc = boardsq[bbc];
        					if (x == nFile(sqDstc)) {
            				if ((lpsmsFileMask->RookCap & PreGen.wBitFileMask[sqDstc]) != 0)
            				{
                			return 17; // 1+16; //9; //1 + 8
            				}
        					}
    						}
  							} // end bbc
            	return 1;
            }
        }
        else if (y == nRank(sqDst)) {
            if ((lpsmsRankMask->CannonCap & PreGen.wBitRankMask[sqDst]) != 0)
            {
            	if (singlechk==0)

                // 6. 判断是否被车将军
                //for (int bbc=31-side; bbc>=28; bbc-=2)
    						for (int bbc=rook_index[oppside(side)];  bbc>=28; bbc-=2)
								{
    						//sqDstc = boardsq[bbc];
    						//if (sqDstc >=0 )
    						//if (NOTSQEMPTY(sqDstc))
    						//	{
    								if (NOTSQEMPTY(boardsq[bbc]))
    	{
    		int sqDstc = boardsq[bbc];
        					if (y == nRank(sqDstc)) {
            				if ((lpsmsRankMask->RookCap & PreGen.wBitRankMask[sqDstc]) != 0)
            				{
                			return (sqDstc < kingpos ? 18: 19); //11 : 10);	//? 3 : 2); + 16
            				}
        					}
    						}
  							} // end bbc

                return (sqDst < kingpos ? 2 : 3); //3 : 2);
            }
        }
    }
  } // end bb

    // 5. 判断是否被车将军
//for (bb=31-side; bb>=28; bb-=2)
for (bb=rook_index[oppside(side)];  bb>=28; bb-=2)
{

    //sqDst = boardsq[bb];
    //if (sqDst >=0 )
    //	if (NOTSQEMPTY(sqDst))
    //{
    	if (NOTSQEMPTY(boardsq[bb]))
    	{
    		int sqDst = boardsq[bb];
        if (y == nRank(sqDst))
        {
            if ((lpsmsRankMask->RookCap & PreGen.wBitRankMask[sqDst]) != 0)
            {
                return (sqDst < kingpos ? 2 : 3); //3 : 2);
            }
        }
        else if (x == nFile(sqDst)) {
            if ((lpsmsFileMask->RookCap & PreGen.wBitFileMask[sqDst]) != 0)
            {
            		return 1;
            }
        }
    }
  } // end bb



    // 4. 判断是否被马将军
    //for (bb=23-side; bb>=20; bb-=2)
    for (bb=hors_index[oppside(side)]; bb>=20;  bb-=2)
		{
	//sqDst = boardsq[bb];
    //if (sqDst >=0 )
    	//if (NOTSQEMPTY(sqDst))
    	//{
    		if (NOTSQEMPTY(boardsq[bb]))
    	{
    		int sqDst = boardsq[bb];
    int nDisp=horsdiff[sqDst-kingpos]; // +90];
    if (nDisp !=0 && (piece[kingpos+nDisp]==0))
        //return 4;
        return (nFile(sqDst) < x ? (nRank(sqDst) < y ? 4 : 5) : (nRank(sqDst) < y ? 6 : 7) );
    }
} // end bb

    // 7. 判断是否被兵(卒)将军

//if ((bitattk[side] | bitattk[2+side] | bitattk[4+side]) & (0x00000AA8 >>side))
//{
    int piecey = piece[kingpos + 16 - (side << 5)]; //down for black, up for white
    if ((piecey <= R_PAWN5) && piecey && ((piecey & 1)!=side) ) return 8; //1;

    piecey = piece[kingpos+1];
    if ((piecey <= R_PAWN5) && piecey) return 8; //10; //2;
    piecey = piece[kingpos-1];
    if ((piecey <= R_PAWN5) && piecey) return 8; //9; //3;



//}

    return 0;
}
template int  Board::IsInCheck<0>(int singlechk);
template int  Board::IsInCheck<1>(int singlechk);
/*
inline int Board::IsInCheckbyRookCann(int DstSq, int bbr)
{
    SlideMaskStruct *lpsmsRankMask, *lpsmsFileMask;

    int kingpos = boardsq[33 - m_side];
//    if (!(NOTSQEMPTY(kingpos)))
//    	return 0;

//2.获得帅(将)所在格子的位行和位列

    int kingRank = nRank(kingpos); // / 9;
    int kingFile = nFile(kingpos); //kingpos - ((y<<3) + y); //(y * 9); //nFile(kingpos); // % 9;
    lpsmsRankMask = PreGen.smsRankMaskTab[kingFile ] + wBitRanks[kingRank];
    lpsmsFileMask = PreGen.smsFileMaskTab[kingRank ] + wBitFiles[kingFile];

    // 5. 判断是否被车将军
    if (bbr >= 28)
    {
        if ((kingRank == nRank(DstSq))
            && ((lpsmsRankMask->RookCap & PreGen.wBitRankMask[DstSq]) != 0))
                return 1;
        else
        if ((kingFile == nFile(DstSq))
            && ((lpsmsFileMask->RookCap & PreGen.wBitFileMask[DstSq]) != 0))
            	  return 1;

    }
    // 6. 判断是否被炮将军
    else
    {
        if ((kingFile == nFile(DstSq))
            && ((lpsmsFileMask->CannonCap & PreGen.wBitFileMask[DstSq]) != 0))
            	  return 1;
        else
        if ((kingRank == nRank(DstSq))
            && ((lpsmsRankMask->CannonCap & PreGen.wBitRankMask[DstSq]) != 0))
                return 1;

    }

    return 0;
}
*/
// IsChasing(chaserpos, pos) = pos is chased by piece(at chaserpos) of color=side
int Board::IsChasing(int sqDst, int pos)
{


    int  nDisp, x, y; //,xx; // , nfile, nrank;
    SlideMaskStruct *lpsmsRankMask, *lpsmsFileMask;
    int retval=0;
    int chaser=(piece[sqDst]>>2);
    switch(chaser)
    {
    	case HORSE:
    // chased by hors? 判断是否被马保护

    //for (int bb=hors_index[side];  bb>=20; bb-=2)
		//{
    //if (NOTSQEMPTY(boardsq[bb]))
    	//{
    		//sqDst = boardsq[bb];
        nDisp=horsdiff[sqDst-pos]; // +90];
        if (nDisp !=0 && (piece[pos+nDisp]==0)) retval=1; //3;
    //}
  //} // end bb
  break;


   case CANNON:
   case ROOK:

    // 2. 获得帅(将)所在格子的位行和位列
    y = nRank(pos); // / 9;
		x = nFile(pos); //pos - ((y<<3) + y); //(y * 9); //nFile(pos); // % 9;

    lpsmsRankMask = PreGen.smsRankMaskTab[x ] + wBitRanks[y];
    lpsmsFileMask = PreGen.smsFileMaskTab[y ] + wBitFiles[x];


    // 6. 判断是否被炮保护

    //for (int bb=cann_index[side]; bb>=24;  bb-=2)
		//{
    	//if (NOTSQEMPTY(boardsq[bb]))
    	//{
    		//sqDst = boardsq[bb];
    		if (y == nRank(sqDst))
    		{
            if (( (chaser==CANNON ? lpsmsRankMask->CannonCap : lpsmsRankMask->RookCap)
            	& PreGen.wBitRankMask[sqDst]) != 0)
            	retval=1; //2;
        }
        else if (x == nFile(sqDst))
        {
            if (( (chaser==CANNON ? lpsmsFileMask->CannonCap : lpsmsFileMask->RookCap)
            	& PreGen.wBitFileMask[sqDst]) != 0)
            	retval=1; //2;
        }

    //}
  //} // end bb
  break;
   /*
    case ROOK:

    // 2. 获得帅(将)所在格子的位行和位列
    y = nRank(pos); // / 9;
		x = nFile(pos); //pos - ((y<<3) + y); //(y * 9); //nFile(pos); // % 9;

    lpsmsRankMask = PreGen.smsRankMaskTab[x ] + wBitRanks[y];
    lpsmsFileMask = PreGen.smsFileMaskTab[y ] + wBitFiles[x];

		     // 5. 判断是否被车保护

    //for (int bb=rook_index[side];  bb>=28;  bb-=2)
		//{
    //if (NOTSQEMPTY(boardsq[bb]))
    	//{
    		//sqDst = boardsq[bb];
        if (y == nRank(sqDst))
        {
            if ((lpsmsRankMask->RookCap & PreGen.wBitRankMask[sqDst]) != 0)  retval=1;
        }
        else if (x == nFile(sqDst))
        {
            if ((lpsmsFileMask->RookCap & PreGen.wBitFileMask[sqDst]) != 0)  retval=1;
        }

    //}
  //} // end bb
  break;
  */
  /* ignore chasing by elephant/ADVISOR/king

    //if (int(pos <80) != side)	//HomeHalf
    if (HOMEHALF(pos, side))
    {
        // 3. 判断受到相(象)的保护
    //for (int bb=18+side; bb>=16;  bb-=2)
    for (int bb=elep_index[side];  bb>=16;  bb-=2)
		{
        //sqDst = boardsq[bb];
        //if (sqDst >=0 )
        //	if (NOTSQEMPTY(sqDst))
        //	 {
        if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
            if ((c_LegalMoveTab[sqDst - pos] == 2) // + 90] == 3)
                    && (piece[(pos + sqDst) >> 1] == 0) )
            {
                return 5;
            }
        }
      } // end bb

        //if (c_InFort[pos])
        if (kingindex[pos] >=0)
        {

            // 2. 判断受到仕(士)的保护
            //for (int bb=14+side; bb>=12; bb-=2)
    				for (int bb=advs_index[side];  bb>=12; bb-=2)
						{
            //sqDst = boardsq[bb];
            //if (sqDst >=0 )
            //if (NOTSQEMPTY(sqDst))
            //	 {
            if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
                if (c_LegalMoveTab[sqDst - pos] == 3) // + 90] == 2)
                {
                    return 5;
                }
            }
          } // end bb


// 1. 判断受到帅(将)的保护
        //sqDst = boardsq[32+side];
        //if (sqDst >=0 )
        //{
              if (NOTSQEMPTY(boardsq[32+side]))
    	{
    		sqDst = boardsq[32+side];
            if (c_LegalMoveTab[sqDst - pos] == 1)  // + 90] == 1)
            {
                return 5;
            }
        }
		} //endif kingindex
    } //endif HomeHalf



		else
		{
*/
/* pawn can chase perpetually
    case 0:
    case 1:
    case 2:
    // 5. 判断受到过河兵(卒)的保护
    				x = nFile(pos);
            if (x>0)
            {
                nDisp = piece[pos - 1];
                if (nDisp && (nDisp <= R_PAWN5) && ((nDisp & 1)==m_side) ) return 1; //4; //&& boardsq[piecey]>=0) return 4;
            }
            if (x<8)
            {
                nDisp = piece[pos + 1];
                if (nDisp && (nDisp <= R_PAWN5) && ((nDisp & 1)==m_side) ) return 1; //4; //&& boardsq[piecey]>=0) return 4;
            }

        //nDisp = piece[pos + 16 - (side << 5)]; //down for black, up for white
        nDisp = piece[pos + (m_side << 5) - 16]; //-16 for black, +16 for white
        if (nDisp && (nDisp <= R_PAWN5) &&  ((nDisp & 1)==m_side) ) return 1; //4; //&& boardsq[piecey]>=0) return 4;
  break;
*/
  } //end switch

    //can chase protected piece. ROOKs are not protected
    if (retval != 0)
    if (piece[pos]< B_ROOK1)
    if (m_side ? IsAttackedBy<1>(pos) : IsAttackedBy<0>(pos))
    	return 0;

    return retval;
}

// IsAttackedBy(m_side, pos) = pos is attacked by piece of m_side or color
template<int side>
int Board::IsAttackedBy(int pos) //(int side, int pos)
{
    int  sqDst, nDisp, x, y; //,xx; // , nfile, nrank;

    // 4. 判断是否被马保护


    //for (int bb=22+side; bb>=20; bb-=2)
    for (int bb=hors_index[side];  bb>=20; bb-=2)
		{
    //sqDst = boardsq[bb];
    //if (sqDst >=0 )
    //	if (NOTSQEMPTY(sqDst))
    //	{
    if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
        nDisp=horsdiff[sqDst-pos]; // +90];
        if (nDisp !=0 && (piece[pos+nDisp]==0)) return 3;
    }
  } // end bb



    SlideMaskStruct *lpsmsRankMask, *lpsmsFileMask;
    // 2. 获得帅(将)所在格子的位行和位列
    y = nRank(pos); // / 9;
		x = nFile(pos); //pos - ((y<<3) + y); //(y * 9); //nFile(pos); // % 9;

    lpsmsRankMask = PreGen.smsRankMaskTab[x ] + wBitRanks[y];
    lpsmsFileMask = PreGen.smsFileMaskTab[y ] + wBitFiles[x];

		     // 5. 判断是否被车保护
    //for (int bb=30+side; bb>=28; bb-=2)
    for (int bb=rook_index[side];  bb>=28;  bb-=2)
		{
    //sqDst = boardsq[bb];
    //if (sqDst >=0 )
    //	if (NOTSQEMPTY(sqDst))
    //{
    if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
        if (y == nRank(sqDst)) {
            if ((lpsmsRankMask->RookCap & PreGen.wBitRankMask[sqDst]) != 0)  return 1;
        }
        else if (x == nFile(sqDst)) {
            if ((lpsmsFileMask->RookCap & PreGen.wBitFileMask[sqDst]) != 0)  return 1;
        }

    }
  } // end bb

    // 6. 判断是否被炮保护
    //for (int bb=26+side; bb>=24; bb-=2)
    for (int bb=cann_index[side]; bb>=24;  bb-=2)
		{
    //sqDst = boardsq[bb];
    //if (sqDst >=0 )
    	//if (NOTSQEMPTY(sqDst))
    	//{
    	if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
    		if (y == nRank(sqDst)) {
            if ((lpsmsRankMask->CannonCap & PreGen.wBitRankMask[sqDst]) != 0)  return 2;
        }
        else if (x == nFile(sqDst)) {
            if ((lpsmsFileMask->CannonCap & PreGen.wBitFileMask[sqDst]) != 0)  return 2;
        }

    }
  } // end bb

    //if (int(pos <80) != side)	//HomeHalf
    if (HOMEHALF(pos, side))
    {
        // 3. 判断受到相(象)的保护
    //for (int bb=18+side; bb>=16;  bb-=2)
    for (int bb=elep_index[side];  bb>=16;  bb-=2)
		{
        //sqDst = boardsq[bb];
        //if (sqDst >=0 )
        //	if (NOTSQEMPTY(sqDst))
        //	 {
        if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
            if ((c_LegalMoveTab[sqDst - pos] == 2) // + 90] == 3)
                    && (piece[(pos + sqDst) >> 1] == 0) )
            {
                return 5;
            }
        }
      } // end bb

        //if (c_InFort[pos])
        if (kingindex[pos] >=0)
        {

            // 2. 判断受到仕(士)的保护
            //for (int bb=14+side; bb>=12; bb-=2)
    				for (int bb=advs_index[side];  bb>=12; bb-=2)
						{
            //sqDst = boardsq[bb];
            //if (sqDst >=0 )
            //if (NOTSQEMPTY(sqDst))
            //	 {
            if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
                if (c_LegalMoveTab[sqDst - pos] == 3) // + 90] == 2)
                {
                    return 5;
                }
            }
          } // end bb


// 1. 判断受到帅(将)的保护
        //sqDst = boardsq[32+side];
        //if (sqDst >=0 )
        //{
              if (NOTSQEMPTY(boardsq[32+side]))
    	{
    		sqDst = boardsq[32+side];
            if (c_LegalMoveTab[sqDst - pos] == 1)  // + 90] == 1)
            {
                return 5;
            }
        }
		} //endif kingindex
    } //endif HomeHalf



		else
		{
    // 5. 判断受到过河兵(卒)的保护
    //int piecey; use nDisp

    //nrank=nRank(pos);
    //if ((side!=BLACK && nrank>=4) || (side==BLACK && nrank <6))
    //if (side == int(y >= 6 - (side<<1)))



        //if ((side==BLACK && pos <80) || (side!=BLACK && pos >=80))
        //if (side != int(pos <80))
        	//nfile=nFile(pos);
        //if (OPPHALF(pos, side))
        //{
            if (x>0)
            {
                nDisp = piece[pos - 1];
                if (nDisp && (nDisp <= R_PAWN5) && ((nDisp & 1)==side) ) return 4; //&& boardsq[piecey]>=0) return 4;
            }
            if (x<8)
            {
                nDisp = piece[pos + 1];
                if (nDisp && (nDisp <= R_PAWN5) && ((nDisp & 1)==side) ) return 4; //&& boardsq[piecey]>=0) return 4;
            }

        //nDisp = piece[pos + 16 - (side << 5)]; //down for black, up for white
        nDisp = piece[pos + (side << 5) - 16]; //-16 for black, +16 for white
        if (nDisp && (nDisp <= R_PAWN5) &&  ((nDisp & 1)==side) ) return 4; //&& boardsq[piecey]>=0) return 4;
  }



    return 0;
}

// Countkingattkpt(side, pos) = kingattkpt pos is attacked by piece of side (RCHP only)
#define KATTKRET 8 //1
template<int side>
inline
int Board::Countkingattkpt(int pos, int oppkingpos)
{
    int  sqDst, nDisp, x, y; //,xx; // , nfile, nrank;
    // 2. 获得帅(将)所在格子的位行和位列
    //y = nRank(pos); // / 9;
		//x = nFile(pos); //pos - ((y<<3) + y); //(y * 9); //nFile(pos); // % 9;

    // 5. 判断受到过河兵(卒)的保护

            //if (x>0)
            {
                nDisp = piece[pos - 1];
                if (nDisp && (nDisp <= R_PAWN5) && ((nDisp & 1)==side) ) return KATTKRET+KATTKRET; //&& boardsq[piecey]>=0) return 4;
            }
            //if (x<8)
            {
                nDisp = piece[pos + 1];
                if (nDisp && (nDisp <= R_PAWN5) && ((nDisp & 1)==side) ) return KATTKRET+KATTKRET; //&& boardsq[piecey]>=0) return 4;
            }

        //nDisp = piece[pos + 16 - (side << 5)]; //down for black, up for white
        nDisp = piece[pos + (side << 5) - 16]; //-16 for black, +16 for white
        if (nDisp && (nDisp <= R_PAWN5) &&  ((nDisp & 1)==side) ) return KATTKRET+KATTKRET; //&& boardsq[piecey]>=0) return 4;

    // 4. 判断是否被马保护

    //for (int bb=22+side; bb>=20; bb-=2)
    for (int bb=hors_index[side];  bb>=20; bb-=2)
		{
    if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
        nDisp=horsdiff[sqDst-pos]; // +90];
        if (nDisp !=0 && (piece[pos+nDisp]==0)) return KATTKRET; //1;
    }
  } // end bb

  // 2. 获得帅(将)所在格子的位行和位列
  x = nFile(pos);
  y = nRank(pos); // / 9;
    SlideMaskStruct *lpsmsRankMask, *lpsmsFileMask;


    lpsmsRankMask = PreGen.smsRankMaskTab[x ] + wBitRanks[y];
    lpsmsFileMask = PreGen.smsFileMaskTab[y ] + wBitFiles[x];



    // 3. 判断是否将帅对脸
    //
/*
    //if (NOTSQEMPTY(boardsq[32+side]))
    	{
    	sqDst = boardsq[32+side];
    	if (x == nFile(sqDst) && (lpsmsFileMask->RookCap & PreGen.wBitFileMask[sqDst]) != 0) {
        return 1;
    	}
		}
*/
		     // 5. 判断是否被车保护
    //for (int bb=30+side; bb>=28; bb-=2)
    for (int bb=rook_index[side];  bb>=28;  bb-=2)
		{
    if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
        if (y == nRank(sqDst)) {
            if ((lpsmsRankMask->RookCap & PreGen.wBitRankMask[sqDst]) != 0)  return KATTKRET;
        }
        else if (x == nFile(sqDst)) {
            if ((lpsmsFileMask->RookCap & PreGen.wBitFileMask[sqDst]) != 0)  return KATTKRET;
        }

    }
  } // end bb

    // 6. 判断是否被炮保护
    //for (int bb=26+side; bb>=24; bb-=2)
    for (int bb=cann_index[side]; bb>=24;  bb-=2)
		{
    	if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
    		if (y == nRank(sqDst)) {
            if ((lpsmsRankMask->CannonCap & PreGen.wBitRankMask[sqDst]) != 0
            	// not attacked if king is the cannon pivot
            	&& ((lpsmsRankMask->RookCap & PreGen.wBitRankMask[boardsq[33-side]]) == 0)
            	)  return KATTKRET;
        }
        else if (x == nFile(sqDst)) {
            if ((lpsmsFileMask->CannonCap & PreGen.wBitFileMask[sqDst]) != 0
            &&	((lpsmsFileMask->RookCap & PreGen.wBitFileMask[boardsq[33-side]]) == 0)
            	)  return KATTKRET;
        }

    }
  } // end bb




    return 0;
}


inline
int Board::get_smallest_attacker(int pos) // ,int &see_getcnt)
{
    int  sqDst, x, y, piecey, nDisp; //,xx; //, nfile, nrank;

    //int blackpos = int(pos <80);
    // 5. 判断受到兵(卒)的attack
    y = nRank(pos); // / 9;
    x = nFile(pos); //pos - ((y<<3) + y); //(y * 9);

//if ((side==BLACK && nrank>=4) || (side==WHITE && nrank <6))
    //if (side == int(y >= 6 - (side<<1)))
    //if (oside != int(y >= 4 + (oside+oside)))
    if ((m_side==0 && y>=4) || (m_side!=0 && y<6))
    {
        sqDst = pos - 16 + (m_side << 5);
        //if (sqDst >=0 && sqDst <BOARD_SIZE-7)
        {
            piecey = piece[sqDst]; //down for white, up for black
            if (piecey && (piecey <= R_PAWN5) && ((piecey & 1)==m_side) )
            	{

            		return sqDst; //&& boardsq[piecey]>=0) return 4;
            	}
        }

    }



// cross river
        if (OPPHALF(pos, m_side))
        {
            if (x>0)
            {
                piecey = piece[pos - 1];
                if (piecey && (piecey <= R_PAWN5) && ((piecey & 1)==m_side) )
                	{
                		return sqDst; //&& boardsq[piecey]>=0) return 4;
                	}
            }

            if (x<8)
            {
                piecey = piece[pos + 1];
                if (piecey && (piecey <= R_PAWN5) && ((piecey & 1)==m_side) )
                	{
                		return sqDst; //&& boardsq[piecey]>=0) return 4;
                	}
            }
         }
         else // if HOMEHALF
         {
        // 3. 判断受到相(象)的保护
    //for (bb=18+m_side; bb>=16; bb-=2)
    for (int bb=elep_index[m_side];  bb>=16; bb-=2)
		{
        if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
            if ((c_LegalMoveTab[sqDst - pos] == 2) // + 90] == 3)
                    && (piece[(pos + sqDst) >> 1] == 0) )
            {
                return sqDst;
            }
        }
    } // end bb



        //if (c_InFort[pos])
        if (kingindex[pos] >=0)
        {
            // 2. 判断受到仕(士)的保护
            //for (bb=14+m_side; bb>=12; bb-=2)
    				for (int bb=advs_index[m_side];  bb>=12; bb-=2)
						{
           if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
                if (c_LegalMoveTab[sqDst - pos] == 3) // + 90] == 2)
                {
                    return sqDst;
                }
            }
          } // end bb
        } // end kingindex
    } //end else HomeHalf




    // 4. 判断是否被马保护
    //for (bb=22+m_side; bb>=20; bb-=2)
    for (int bb=hors_index[m_side]; bb>=20;  bb-=2)
		{
    if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
        nDisp=horsdiff[sqDst - pos]; // +90];
        if (nDisp !=0 && (piece[pos+nDisp]==0))
        	{

        		return sqDst;
        	}
    }
} // end bb


    // 2. 获得帅(将)所在格子的位行和位列
    SlideMaskStruct *lpsmsRankMask, *lpsmsFileMask;
    //y = nRank(pos); // / 9;
    //x = nFile(pos); //pos - ((y<<3) + y); //(y * 9); //nFile(pos); // % 9;
    lpsmsRankMask = PreGen.smsRankMaskTab[x ] + wBitRanks[y];
    lpsmsFileMask = PreGen.smsFileMaskTab[y ] + wBitFiles[x];

    // 6. 判断是否被炮保护
    //for (bb=26+m_side; bb>=24; bb-=2)
    for (int bb=cann_index[m_side]; bb>=24;  bb-=2)
		{
    //sqDst = boardsq[bb];
    //if (sqDst >=0 )
    	//if (NOTSQEMPTY(sqDst))
    	//{
    	if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
        if (x == nFile(sqDst)) {
            if ((lpsmsFileMask->CannonCap & PreGen.wBitFileMask[sqDst]) != 0)  return sqDst;
        } else if (y == nRank(sqDst)) {
            if ((lpsmsRankMask->CannonCap & PreGen.wBitRankMask[sqDst]) != 0)  return sqDst;
        }
    }
  } // end bb

//SlideMaskStruct *lpsmsRankMask, *lpsmsFileMask;
    //y = nRank(pos); // / 9;
    //x = nFile(pos); //pos - ((y<<3) + y); //(y * 9); //nFile(pos); // % 9;

    // 5. 判断是否被车保护
    //for (bb=30+m_side; bb>=28; bb-=2)
    for (int bb=rook_index[m_side];  bb>=28; bb-=2)
		{
    //sqDst = boardsq[bb];
    //if (sqDst >=0 )
    //if (NOTSQEMPTY(sqDst))
    //	{
    if (NOTSQEMPTY(boardsq[bb]))
    	{
    		sqDst = boardsq[bb];
        if (x == nFile(sqDst)) {
            if ((lpsmsFileMask->RookCap & PreGen.wBitFileMask[sqDst]) != 0)  return sqDst;
        } else if (y == nRank(sqDst)) {
            if ((lpsmsRankMask->RookCap & PreGen.wBitRankMask[sqDst]) != 0)  return sqDst;
        }
    }
  } // end bb

// 1. 判断受到帅(将)的保护
    //if (c_InFort[pos])
    if (kingindex[pos] >=0)
		if (HOMEHALF(pos, m_side))
           // && m_side != int(pos <80)
    //if (homeside && kingindex[pos] >=0)
    {
        sqDst = boardsq[32+m_side];
        //if (sqDst >=0 )
        if (NOTSQEMPTY(sqDst))
        {
            if (c_LegalMoveTab[sqDst - pos] == 1)  // + 90] == 1)
            {
                return sqDst;
            }
        }
    }


    return -1; //0;
}

inline int Board::makemovesee(int from, int dest)
{
    HistRecord *hisptr;
    hisptr = m_hisrecord + m_hisindex;
    int piecefrom=piece[from];
    int piecedest=piece[dest];


    wBitRanks[nRank(from)] ^= PreGen.wBitRankMask[from];  // / 9
    wBitFiles[nFile(from)] ^= PreGen.wBitFileMask[from];  // % 9


    // 2. 如果没有被吃的棋子，那么更新目标格的位行和位列。
    //    换句话说，有被吃的棋子，目标格的位行和位列就不必更新了。
		//if (piecedest)
    {
        boardsq[piecedest]=SQ_EMPTY;

    }



		boardsq[piecefrom] = dest;
    piece[dest]=piecefrom;
    piece[from]=EMPTY;
    /*
		int kingidx=kingindex[boardsq[32+m_side]];
    if (kingattk_incl_horse[kingidx][dest] || kingattk_incl_horse[kingidx][from])
    */

    //if (IsInCheck(m_side,1)) //singlechk
    if (IsInCheck<1>(m_side)) //singlechk
    {
        piece[from]=piece[dest];
        piece[dest]=piecedest;
        //if (piecedest)
       {
       	 boardsq[piecedest] = dest;

       }
        wBitRanks[nRank(from)] ^= PreGen.wBitRankMask[from];
        wBitFiles[nFile(from)] ^= PreGen.wBitFileMask[from];

        boardsq[piecefrom] = from;

        return -1;
    }

    chgside(m_side);

    hisptr->htab.table.move = (from<<8)+dest;
    hisptr->htab.capture = piecedest;

    m_hisindex++;

//    if (printed==0 )
//			{	printf("makemovesee: m_side=%d, from=%d, dest=%d, piecefrom=%d, piecedest=%d\n", m_side, from, dest, piecefrom, piecedest);
//		printed=1;
//		}
    return piecedest;
}

inline void Board::unmakemovesee()
{
		HistRecord *hisptr;
    m_hisindex--;
    hisptr = m_hisrecord + m_hisindex;

    int dest=hisptr->htab.dest;
    int from=hisptr->htab.from;
    int piecefrom=piece[dest];
    int piecedest=hisptr->htab.capture;


    piece[from]=piecefrom;
    piece[dest]=piecedest;
		chgside(m_side);

    //if (piecedest)
    {
        boardsq[piecedest] = dest;

    }
		boardsq[piecefrom] = from;
    wBitRanks[nRank(from)] ^= PreGen.wBitRankMask[from];
    wBitFiles[nFile(from)] ^= PreGen.wBitFileMask[from];
}

/*
/// Position::see_ge (Static Exchange Evaluation Greater or Equal) tests if the
/// SEE value of move is greater or equal to the given threshold. We'll use an
/// algorithm similar to alpha-beta pruning with a null window.

bool Position::see_ge(Move m, Value threshold) const {

  assert(is_ok(m));

  // Only deal with normal moves, assume others pass a simple see
  if (type_of(m) != NORMAL)
      return VALUE_ZERO >= threshold;

  Bitboard stmAttackers;
  Square from = from_sq(m), to = to_sq(m);
  PieceType nextVictim = type_of(piece_on(from));
  Color us = color_of(piece_on(from));
  Color stm = ~us; // First consider opponent's move
  Value balance;   // Values of the pieces taken by us minus opponent's ones

  // The opponent may be able to recapture so this is the best result
  // we can hope for.
  balance = PieceValue[MG][piece_on(to)] - threshold;

  if (balance < VALUE_ZERO)
      return false;

  // Now assume the worst possible result: that the opponent can
  // capture our piece for free.
  balance -= PieceValue[MG][nextVictim];

  // If it is enough (like in PxQ) then return immediately. Note that
  // in case nextVictim == KING we always return here, this is ok
  // if the given move is legal.
  if (balance >= VALUE_ZERO)
      return true;

  // Find all attackers to the destination square, with the moving piece
  // removed, but possibly an X-ray attacker added behind it.
  Bitboard occupied = pieces() ^ from ^ to;
  Bitboard attackers = attackers_to(to, occupied) & occupied;

  while (true)
  {
      stmAttackers = attackers & pieces(stm);

      // Don't allow pinned pieces to attack (except the king) as long as
      // all pinners are on their original square.
      if (!(st->pinners[~stm] & ~occupied))
          stmAttackers &= ~st->blockersForKing[stm];

      // If stm has no more attackers then give up: stm loses
      if (!stmAttackers)
          break;

      // Locate and remove the next least valuable attacker, and add to
      // the bitboard 'attackers' the possibly X-ray attackers behind it.
      nextVictim = min_attacker<PAWN>(byTypeBB, to, stmAttackers, occupied, attackers);

      stm = ~stm; // Switch side to move

      // Negamax the balance with alpha = balance, beta = balance+1 and
      // add nextVictim's value.
      //
      //      (balance, balance+1) -> (-balance-1, -balance)
      //
      assert(balance < VALUE_ZERO);

      balance = -balance - 1 - PieceValue[MG][nextVictim];

      // If balance is still non-negative after giving away nextVictim then we
      // win. The only thing to be careful about it is that we should revert
      // stm if we captured with the king when the opponent still has attackers.
      if (balance >= VALUE_ZERO)
      {
          if (nextVictim == KING && (attackers & pieces(stm)))
              stm = ~stm;
          break;
      }
      assert(nextVictim != KING);
  }
  return us != stm; // We break the above loop when stm loses
}
*/
bool Board::non_pawn_material(int m_side)
{
	return (bitpiece & (0xfff00000)) ;
}	

extern int VR,VRE,VN,VNE,VC,VCE;
int Board::non_pawn_material()     
{
	// VR=4570 VRE=4600 V
	///RrRrCcCc HhHhEeEe BbBbPpPp PpPpPpKk
	return PCbitCount(bitpiece & 0xf0000000) * VRE + PCbitCount(bitpiece & 0x0f000000) * VCE +
	 PCbitCount(bitpiece & 0x00f00000) * VNE ;  
}

/// Position::see_ge (Static Exchange Evaluation Greater or Equal) tests if the
/// SEE value of move is greater or equal to the given threshold. We'll use an
/// algorithm similar to alpha-beta pruning with a null window.

bool Board::see_ge(int from, int dest, int threshold) {

  assert(is_ok(from, dest));
  
  int attksq, capture, seemovecnt;
 
  // not for xiangqi. Only deal with normal moves, assume others pass a simple see
  //if (type_of(m) != NORMAL)
  //    return VALUE_ZERO >= threshold;

  //Bitboard stmAttackers;
  //Square from = from_sq(m), to = to_sq(m);
  //PieceType nextVictim = type_of(piece_on(from));
  int  nextVictim = piece[from];
  //Color us = color_of(piece_on(from));
  //Color stm = ~us; // First consider opponent's move
  int us = color_of(nextVictim); //piece[from]);
  int stm = oppside(us); // ~us; // First consider opponent's move
  int balance;   // Values of the pieces taken by us minus opponent's ones

  // The opponent may be able to recapture so this is the best result
  // we can hope for.
  //balance = PieceValue[MG][piece_on(to)] - threshold;
  capture = piece[dest];
  if (capture <= R_PAWN5 && (OPPHALF(dest, m_side)))
            capture += 34;	//cross-river pawn value
  balance = (PIECE_VALUE_side[capture]) - threshold;

   capture=makemovesee(from, dest);
     if (capture < 0)
        return false; //-9999;
   seemovecnt = 1;     

  if (balance < 0) //VALUE_ZERO)
  {	unmakemovesee();
      return false;
  }
  // Now assume the worst possible result: that the opponent can
  // capture our piece for free.
  capture = nextVictim;
  if (capture <= R_PAWN5 && (OPPHALF(dest, m_side)))
            capture += 34;	//cross-river pawn value
  balance -= (PIECE_VALUE_side[capture]);

  // If it is enough (like in PxQ) then return immediately. Note that
  // in case nextVictim == KING we always return here, this is ok
  // if the given move is legal.
  if (balance >= 0) //VALUE_ZERO)
  {   unmakemovesee();
      return true;
  }
  //sf10 Find all attackers to the destination square, with the moving piece
  //sf10 removed, but possibly an X-ray attacker added behind it.
  //sf10 Bitboard occupied = pieces() ^ from ^ to;
  //sf10 Bitboard attackers = attackers_to(to, occupied) & occupied;
  
  //seemovecnt = 0; //1;
  while (true)
  {
      //sf10 stmAttackers = attackers & pieces(stm);

      // Don't allow pinned pieces to attack (except the king) as long as
      // all pinners are on their original square.
      //sf10 if (!(st->pinners[~stm] & ~occupied))
      //sf10    stmAttackers &= ~st->blockersForKing[stm];

      // If stm has no more attackers then give up: stm loses
      // if (!stmAttackers)
      //    break;
     
    
        if ( piece[dest]==0 || (piece[dest]&1)==m_side)
            break;
        attksq = get_smallest_attacker(dest);
        if (attksq < 0) //==0) // The square isn't attacked anymore by this side
            break;

      // Locate and remove the next least valuable attacker, and add to
      // the bitboard 'attackers' the possibly X-ray attackers behind it.
      // nextVictim = min_attacker<PAWN>(byTypeBB, to, stmAttackers, occupied, attackers);
      nextVictim = piece[attksq];
      capture = nextVictim ;
      if (capture <= R_PAWN5 && (OPPHALF(dest, m_side)))
            capture += 34;	//cross-river pawn value
      chgside(stm); //stm = ~stm; // Switch side to move

      // Negamax the balance with alpha = balance, beta = balance+1 and
      // add nextVictim's value.
      //
      //      (balance, balance+1) -> (-balance-1, -balance)
      //
      assert(balance < 0); //VALUE_ZERO);

      balance = -balance - 1 - (PIECE_VALUE_side[capture]); //PieceValue[MG][nextVictim];

      // If balance is still non-negative after giving away nextVictim then we
      // win. The only thing to be careful about it is that we should revert
      // stm if we captured with the king when the opponent still has attackers.
      if (balance >= 0) //VALUE_ZERO)
      {
          //if (nextVictim == KING && (attackers & pieces(stm)))
          if (nextVictim >= B_KING)
          {
          	  capture=makemovesee(from, dest);
              if (capture < 0)
              {	 //no need if king capture is illegal   //chgside(stm); //stm = ~stm;
                 break; //return false; //-9999;
              }   
              seemovecnt++;
          	  attksq = get_smallest_attacker(dest);
              if (attksq > 0) //==0) // The square KING has attackers             
                 chgside(stm); //stm = ~stm;
          }
          break;
      }
      //assert(nextVictim != KING);
      assert(nextVictim < B_KING);
      
     capture=makemovesee(from, dest);
     if (capture < 0)
        break; //return false; //-9999;
     seemovecnt++;
  }
  // 
  for (int i=1; i<=seemovecnt; i++)
  {
        unmakemovesee();
  }
  return us != stm; // We break the above loop when stm loses
}

//1002 - replace see by see_ge
/*
int Board::see(int from, int dest)
{
    int  capture,see_value, seemovecnt;
    capture=makemovesee(from, dest);
    if (capture < 0)
        return -9999;

    seemovecnt = 0; //1;

    if (capture <= R_PAWN5
    	//&& (m_side != int(dest <80))
    	&& (OPPHALF(dest, m_side))
    	)
        capture += 34;	//cross-river pawn value
    see_value = PIECE_VALUE_side[capture]; //0;
    
  // If it is enough (like in PxQ) then return immediately. Note that
  // in case nextVictim == KING we always return here, this is ok
  // if the given move is legal.
  //if (balance >= VALUE_ZERO)
  //    return true;    

    //see_value = -(pointtable[dest][PIECE_IDX(capture)][p_endgame]);

    //(capture&1) ? assert(see_value>0) : assert(see_value<0);

    for (;;)
    {
        if ( piece[dest]==0 || (piece[dest]&1)==m_side)
            break;
        int attksq = get_smallest_attacker(dest);
        if (attksq < 0) //==0) // The square isn't attacked anymore by this side
            break;
            
      

        //make_capture(piece, square);
        //movetemp.from = board.boardsq[piece];
        //movetemp.dest = dest;

        //printf("info side=%d, attacker=%d, from=%d, dest=%d\n", board.m_side, piece, movetemp.from, square);
        //fflush(stdout);

        capture=makemovesee(attksq, dest); //(boardsq[piece], dest);
        if (capture < 0) break;

        seemovecnt++;

        if (capture <= R_PAWN5
        	//&& (m_side != int(dest <80))
        	&& (OPPHALF(dest, m_side))
        	)
            capture += 34;	//cross-river pawn value

        see_value += PIECE_VALUE_side[capture];

       //int temp_see_value = -(pointtable[dest][PIECE_IDX(capture)][p_endgame]);
       //see_value += temp_see_value;
       	//(capture&1) ? assert(temp_see_value>0) : assert(temp_see_value<0);
    }

    for (int i=seemovecnt; i>=0; i--)
    {
        //undo_capture(piece, square);
        unmakemovesee();
    }
    return (m_side ? -see_value : see_value);
}
*/
/*
inline int Board::see(int from, int dest, int &val)
{
    val=see(from, dest);
    return val;
}
*/
// 着法合理性检测，仅用在“杀手着法”的检测中

int Board::LegalKiller(MoveStruct &moveS)
{
    int Src, Dst, Moved, Captured, Disp, x, y;


//  int DstSq, j, fcannon;
//  char *DstPtr;
    // 着法合理性检测包括以下几个步骤：
    // 1. 检查要走的子是否存在
    //Moved = p_Squares[Move.Src];
    //if ((Moved & (p_Player == 0 ? 16 : 32)) == 0) {
    //  return false;
    //}
    //Src = Move >>8; //Move.from; //Move >>7;
    //Dst = Move &255; //Move.dest; //Move & 127;
    Src = moveS.from;
    Moved = piece[Src];
    if ((Moved == 0) || ((Moved &1) != m_side)) {
        return 0;
    }

    // 2. 检查吃到的子是否为对方棋子(如果有吃子的话)
// Captured = p_Squares[Move.Dst];
// if ((Captured & (p_Player == 0 ? 16 : 32)) != 0) {
//   return false;
// }
		Dst = moveS.dest;
    Captured = piece[Dst];
    if (Captured && ((Captured &1) == m_side)) {
        return 0;
    }




    //piecetype=(Moved>>2);
    //switch (piecetype)
    switch (Moved>>2)
    {
    case 0:
    case 1:
    case 2:
    {	//if (piecetype==0 || piecetype==1 || piecetype==2)

        // 1. 如果是兵(卒)，则按红方和黑方分情况讨论
        //case 0:
        //case 1:
        //case 2:
        if (Moved &1) {  // white pawn
            //if (Dst == Src - 9 || ((Dst) <45 && (Dst == Src - 1 || Dst == Src + 1)) ) return 1;
            if (Dst == Src - 16 || ((Dst) <80 && (Dst == Src - 1 || Dst == Src + 1)) ) return 1;
        } else {
            //if (Dst == Src + 9 || ((Dst) >44 && (Dst == Src - 1 || Dst == Src + 1)) ) return 1;
            if (Dst == Src + 16 || ((Dst) >79 && (Dst == Src - 1 || Dst == Src + 1)) ) return 1;
        }
        return 0;
    }
    // 2. 如果是仕(士)，则先看是否在九宫内，再看是否是合理位移
    //if (piecetype==ADVISOR)
    case ADVISOR:
    {

        if (kingindex[Dst] >=0
                && c_LegalMoveTab[Dst - Src] ==3) return 1;  // + 90] == 2) return 1;
        return 0;
    }
    // 3. 如果是相(象)，则先看是否过河，再看是否是合理位移，最后看有没有被塞象眼
    //else if (piecetype==ELEPHAN)
    case ELEPHAN:
    {
        if (Moved &1) {  // white elephant
            //if ( (Src>44) && (Dst>44) && (c_LegalMoveTab[Dst - Src]==2) // + 90] == 3)
            if ( (Src>79) && (Dst>79) && (c_LegalMoveTab[Dst - Src]==2) // + 90] == 3)
                    && (piece[(Src + Dst) >> 1] == 0) ) return 1;
        } else {
            //if ( (Src<45) && (Dst<45) && (c_LegalMoveTab[Dst - Src]==2) // + 90] == 3)
            if ( (Src<80) && (Dst<80) && (c_LegalMoveTab[Dst - Src]==2) // + 90] == 3)
                    && (piece[(Src + Dst) >> 1] == 0) ) return 1;
        }
        return 0;
    }
    // 4. 如果是马，则先看看是否是合理位移，再看有没有被蹩马腿
    //else if (piecetype==HORSE)
    case HORSE:
    {
        Disp = horsdiff[Src - Dst]; // + 90];

        if (Disp !=0 && (piece[Disp + Dst]==0)) return 1;

        return 0;
    }
    // 5. 如果是炮，判断起来和车一样
    //else if (piecetype==CANNON)
    case CANNON:
    {

        y = nRank(Src);
        x = nFile(Src); //Src - ((y <<3) + y); //(y * 9); //nFile(Src);
        if (x == nFile(Dst)) {
            if (Captured == 0) {
                if ((PreGen.smsFileMaskTab[y ][wBitFiles[x]].NonCap & PreGen.wBitFileMask[Dst]) != 0) return 1;
                else return 0;
            } else {
                if ((PreGen.smsFileMaskTab[y ][wBitFiles[x]].CannonCap & PreGen.wBitFileMask[Dst]) != 0) return 1;
                else return 0;
            }
        } else if (y == nRank(Dst)) {
            if (Captured == 0) {
                if ((PreGen.smsRankMaskTab[x ][wBitRanks[y]].NonCap & PreGen.wBitRankMask[Dst]) != 0) return 1;
                else return 0;
            } else {
                if ((PreGen.smsRankMaskTab[x ][wBitRanks[y]].CannonCap & PreGen.wBitRankMask[Dst]) != 0) return 1;
                else return 0;
            }
        } else {
            return 0;
        }
    }

    // 6. 如果是车?
    //else if (piecetype==ROOK)
    case ROOK:
    {

        y = nRank(Src);
        x = nFile(Src); //Src - ((y <<3) + y); //(y * 9); // nFile(Src);
        if (x == nFile(Dst)) {
            if (Captured == 0) {
                if ((PreGen.smsFileMaskTab[y ][wBitFiles[x]].NonCap & PreGen.wBitFileMask[Dst]) != 0) return 1;
                else return 0;
            } else {
                if ((PreGen.smsFileMaskTab[y ][wBitFiles[x]].RookCap & PreGen.wBitFileMask[Dst]) != 0) return 1;
                else return 0;
            }
        } else if (y == nRank(Dst)) {
            if (Captured == 0) {
                if ((PreGen.smsRankMaskTab[x ][wBitRanks[y]].NonCap & PreGen.wBitRankMask[Dst]) != 0) return 1;
                else return 0;
            } else {
                if ((PreGen.smsRankMaskTab[x ][wBitRanks[y]].RookCap & PreGen.wBitRankMask[Dst]) != 0) return 1;
                else return 0;
            }
        } else {
            return 0;
        }
    }


    // 7. 如果是(将)，则先看是否在九宫内，再看是否是合理位移
    //else if (piecetype==KING)
    case KING:
    {
        //if (c_InFort[Dst]
        if (kingindex[Dst] >=0
                && c_LegalMoveTab[Dst - Src]==1) return 1; // + 90] == 1) return 1;
        return 0;
    }
    //else
    //default:


    } // end switch
    return 0;
}



//static const int ATTKPVAL[34]   = {0,0,2,-2,0,0,0,0,1,-1,1,-1,2,-2,2,-2,2,-2,2,-2, 7,-7,7,-7,4,-4,4,-4,9,-9,9,-9,1,-1};
//static const int ATTKPVAL_3[34] = {0,0,5,-5,3,-3,3,-3,4,-4,4,-4,5,-5,5,-5,6,-6,6,-6,10,-10,10,-10,8,-8,8,-8,12,-12,12,-12,4,-4};
//static const int ATTKPVAL[34]   = {0,0,2,2,0,0,0,0,1,1,1,1,4,4,4,4,2,2,2,2, 7,7,7,7,7,7,7,7,9,9,9,9,1,1};
//static const int ATTKPVAL_3[34] = {0,0,5,5,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,10,10,10,10,10,10,10,10,12,12,12,12,4,4};
extern int ATTKPVAL[34];
extern int ATTKPVAL_3[34];

//extern int SCORE80_20; // = {80,-80, 20, -20};
//extern int SCORE6_2;   // = {6,-6, 2, -2};
//static const int SCORE1Cnt[10][2] = {0,0, 1,-1, 3,-3, 4,-4, 6,-6, 7,-7, 9,-9, 10,-10, 12,-12, 13,-13};
//const int RIVER_POS1[2] = {45, 36};
//const int RIVER_POS2[2] = {53, 44};
// 偷懒评价的边界
//static const int EVAL_MARGIN1 = 256;  //160;
//static const int EVAL_MARGIN2 = 128;  //80;
//static const int EVAL_MARGIN3 = 64;   //40;
//static const int EVAL_MARGIN4 = 32;   //20;
/*
 // 1. 四级偷懒评价(彻底偷懒评价)，只包括子力平衡；
  vl = Material();
  if (vl + EVAL_MARGIN1 <= vlAlpha) {
    return vl + EVAL_MARGIN1;
  } else if (vl - EVAL_MARGIN1 >= vlBeta) {
    return vl - EVAL_MARGIN1;
  }
*/
// [nFile][p_endgame]
/*
static const int PAWN_DOUBLE_BONUS[9][2] =
{ 1, 0,
        1, 0,
        1, 0,
        10,5,
        10,5,
        10,5,
        1, 0,
        1, 0,
        1, 0
};
*/
static const int PAWN_DOUBLE_BONUS[9] =
{ 0,
        1*10,
        1*10,
        7*10,
        7*10,
        7*10,
        1*10,
        1*10,
        0
};
/*
// [c_rook_black][c_rook_red]
static const int ROOK_BONUS[3][4] =
    { 0, -16, -32, 0,
      16,   0, -12, 0,
      32, 12,   0, 0
    };

// [c_cann_black][c_cann_red]
static const int CANN_BONUS[3][4] =
    { 0,-4,-9, 0,
      4,  0,  0, 0,
      9,  0,  0, 0
    };

// [c_hors_black][c_hors_red]
static const int HORS_BONUS[3][4] =
    { 0,-4,-8, 0,
      4,  0,  0, 0,
      8,  0,  0, 0
    };
*/
// [c_rook_black][c_cann_black][c_hors_black]
static const int ROOK_CANN_HORS_BONUS[3][4][4] = {
// {{0,0,11, 0},										// 000 001 002
//	{0,13, 20, 0},									// 010 011 012
//	{7,20, 28, 0},{0,0,0,0}},			  // 020 021 022
 {{0,0,11*10, 0},										// 000 001 002
	{0,14*10, 15*10, 0},									// 010 011 012  //15->14 CH   //21->15 CHH
	{80,17*10, 17*10, 0},{0,0,0,0}},			  // 020 021 022	//21->17 CCH  //28->17 CCHH

  {{12*10,17*10,20*10, 0}, 								// 100 101 102
  	{18*10,33*10, 46*10, 0},								// 110 111 112  //17->22->18 RC    //40->48->46 RCHH
  	 {25*10,46*10,46*10, 0},{0,0,0,0}},		// 120 121 122  //27->22->25 RCC  40->49->46 RCCH  //50->49->46 RCCHH

  {{32*10,34*10,34*10, 0}, 								// 200 201 202		//38->34 RRH  //44->34 RRHH
  	{35*10, 55*10, 55*10, 0}, 								// 210 211 212  //38->35 RRC
  	{38*10, 58*10, 58*10, 0},{0,0,0,0}}};		// 220 221 222                //45->38 RRCC

// [c_rook_black][c_ADVISOR_red]
static const int ROOK_ADVISOR_BONUS[3][4] =
{ {0,0,0,0},
	{0,0,0,0},
	{1112, 550,0,0}};   //1108 rook_advisor *10  1120,550


// [c_cann_black][c_elep_red]
static const int CANN_ELEP_BONUS[3][4] =
{ {0,   0, 0, 0},
  {12*10,  10*10, 0, 0},
  {12*10,  10*10,0, 0}};

// [c_hors_black][c_advs_red]
//static const int HORS_ADVS_BONUS[3][4] =
//{ 0,   0, 0, 0,
//  10,  10, 0, 0,
//  15,  10,0, 0};

/*
// [c_cann_black][c_hors_black][c_cann_red][c_hors_red]
static const int CANN_HORS_BONUS[3][3][3][4] =
{ 0,   0,   0, 0,   0,   0,   0, 0,   0,   0,   0, 0,
  0,   0,   0, 0,   0,   0,   0, 0,   0,   0,   0, 0,
  0,   0,   0, 0,	  0, -13, -13, 0,  -5, -13, -13, 0,

  0,   0,   0, 0,   0,   0,   0, 0,   0,   0,   0, 0,
  0,   0,  13, 0,   0,   0,   0, 0,  13,   0,   0, 0,
  0,   0,  13, 0,	  0,   0,   0, 0,  13,   0,   0, 0,

  0,   0,   5, 0,   0, -13, -13, 0,   0, -13, -13, 0,
  0,   0,  13, 0,   0,   0,   0, 0,  13,   0,   0, 0,
 0,   0,  13, 0,	  0,   0,   0, 0,  13,   0,   0, 0};
*/
/*
// [c_cann_red][c_elep_red][c_advs_red]
static const int ROOK_DRAW_CANNELEPadvs[3][3][4] =
{ 0,   0,  0, 0,    0,   0,  0, 0,     0,  0, 80, 0,
  0,   0, 80, 0,    0,   0, 80, 0,    80, 80, 80, 0,
  0,   0,  0, 0,	  0,   0,  0, 0,     0,  0, 0, 0};
*/
//马的灵活性奖赏
//-8  -8  -6  -4  0  0  0  2  4  4  4  4  5  5  5  5

//static const int HORSE_MOBSCORE[9] = {-30,-13,-9,-6,0,3,6,8,8};
extern int HORSE_MOBSCORE[9];
//车的灵活性奖赏
//-18  -12  -8  -5  -2  -1  0  2  4  4  4  4  5  5  5  5
//static const int ROOK_MOBSCORE[18][2] = {{-25,25},{-16,16},{-11,11},{-7,7},{-3,3},{-1,1},{0,0},{3,-3},{5,-5},{5,-5},{6,-6},{6,-6},{7,-7},{7,-7},{8,-8},{8,-8},{9,-9},{9,-9}};
static const int ROOK_MOBSCORE[18]={-25*8,-16*8,-11*8,-7*8,-3*8,-1*8,0,3*8,5*8,5*8,6*8,6*8,7*8,7*8,8*8,8*8,9*8,9*8};  //1110
//炮的灵活性奖赏
//-2  -1  0  0  0  0  0  0  0  0  0  0  0  0  1  1
//static const int CANNON_MOBSCORE[18][2] = {{-3,3},{-1,1},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{1,-1},{2,-2},{3,-3},{3,-3}};
static const int CANNON_MOBSCORE[18] = {-3*8,-1*8,0,0,0,0,0,0,0,0,0,0,0,0,1*8,1*8,1*8,1*8};
//先行权奖赏价值,和棋藐视因子
//7 0
//static int MOVEFIRST_BONUS; // 5 //9
//#define MOVEFIRST_BONUS 5 //5
extern int TEMPO_BONUS;  //opening 5  //endgame 0
//#define CONTEMPT_VALUE 16
//下面开始读取特殊盘面情况附加奖赏评价值
//特殊评价的最大边界值随着评价的细致逐级减少
//135

//0到6个棋子配合参加进攻的附加奖赏值(每个棋子分半进攻和全进攻两个级别)
//0 0 0 2 6 30 50 60 65 70 80 90 90
//区域子力不平衡的附加评价值(主要针对侧面多子归边威胁),奖赏随着局部区域兵力差异的增大而增加
//0 0 4 6 8 12 18 24 40 44 64 96 128 192 256 384

//读取一般红中炮随纵坐标不同的威胁分值,大体上越往上压近黑王威胁越大,炮镇窝心马时分值要翻四番
//相对于红中炮对黑方的威胁,黑方情况程序回自己反过来计算
//0   0   0  9  9  6  3  4  1  1
//中炮而且封锁将门的附加值,双士都在但王占中心惩罚
//7 4

//读取一般红中炮随纵坐标不同的威胁分值,大体上越往上压近黑王威胁越大,炮镇窝心马时分值要翻四番
//相对于红中炮对黑方的威胁,黑方情况程序回自己反过来计算
//0   0   0  9  9  6  3  4  1  1
static const int SUPERCAP_SCORE[7] = {14*15,13*15,9*15,5*15,6*15,1*15,1*15};   //1111
static const int SUPERCAP_BOTSCORE[7] = {7*15,6*15,4*15,2*15,2*15,1*15,1*15};  //1111
static const int CENTRAL_HORSE_SCORE[7] = {55*15,50*15,35*15,20*15,24*15,4*15,4*15}; //1111 //{50,48,32,16,20,4,4};
//中炮而且封锁将门的附加值,双士都在但王占中心惩罚
//7 4
//#define DOOR_BONUS 16
//#define KING_BONUS 10
//读取一般红空头炮随纵坐标不同的威胁分值,大体上越往下远离黑王威胁越大
//相对于红中空头炮对黑方的威胁,黑方情况程序回自己反过来计算
//0   0   0  22  25  30  40  60  60  60
//沉底炮的威胁分值,指标是列号,大体上越靠近边线威胁越大
//12  9   1   0   0   0   1  9  12
//3dc92(R=340), eyc(R=460), 460/340=1.35
//extern unsigned char EMPTY_CANN_SCORE[3][16]; // =  {{0,0},{0,0},{34,-34},{40,-40},{48,-48},{60,-60},{90,-90},{90,-90},{90,-90}};
extern int EMPTY_CANN_SCORE[9]; // = {0,0,34,40,48,60,90,90,90};
//{0,0,34,40,48,60,90,90,90};
//{0,0,30,34,41,54,81,81,81};
//{0,0, 8,12,14,17,22,22,22, 0,0,0,0,0,0,0};

//extern int BOTTOM_CANN_SCORE[9][2]; // = {{0,0},{0,0},{13,-13},{18,-18},{18,-18},{18,-18},{18,-18}};
extern int BOTTOM_CANN_SCORE[9]; // = {17,13,2,0,0,0,2,13,17};
//{40,30,3,0,0,0,3,30,40};
//缺少双车惩罚值,缺少双炮惩罚值,缺少双马惩罚值
//12 6 6
//读取双车威胁的附加评价值
//对方缺1个士的奖赏值,对方缺2个士的奖赏值
//35 70

static const int CENTRAL_POS[2] = {132, 20};  //poscolor [0] [1]
static const int ADVISOR_L[2] = {147,5};
static const int ADVISOR_R[2] = {149,3};
static const int rankposcolor1[2] = {-1, 7};
//static const int score1[2] = {1, -1};
//static const int score16[2] = {16, -16};
//static const int score32[2] = {32, -32};
//static const int score64[2] = {64, -64};

#define LEFT 0
#define RIGHT 1

// 0到6个棋子配合参加进攻的附加奖赏值(每个棋子分半进攻和全进攻两个级别)
// 0 0 0 2 6 30 50 60 65 70 80 90 90
// 区域子力不平衡的附加评价值(主要针对侧面多子归边威胁),奖赏随着局部区域兵力差异的增大而增加
// 0 0 4 6 8 12 18 24 40 44 64 96 128 192 256 384
static const int BONUS_ATTK[49]={0,0,0,10,30,150,250,300,325,350,400,450,480, 500,550,600,650,700,750,800,850,900,900,900,900,  //1107
                                   900,900,900,900,900,900,900,900,900,9000,900,900, 900,900,900,900,900,900,900,900,900,900,900,900};  //1107
static const int SCORE_ATTK_[48]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   0,0,40,60,80,120,180,240,400, 440,640,960,1280,1920,2560,3840, 3840,3840,3840,38400,3840,3840,3840,3840,3840, 3840,3840,3840,3840,3840,3840,3840};
static const int *SCORE_ATTK = SCORE_ATTK_ + 16;

//1867p
//static const unsigned char SCORE_COMBAT[24]={0,0,0,0, 1,1,2, 4,6,18,30, 40,50,55,60, 62,65,67,70, 75,80,85,90,90};
//1867q
//static const unsigned char SCORE_COMBAT[12]={0,0,6,50,65,80,90,90,90,90,90,90};

//static const unsigned short SCORE_ATTK_[64]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//	0,0,0,3,6,7,9,10,12,15,18,22,27,31,36,48,60,63,66,81,96,120,144,168,192,240,288,336,384,480,576,576};
//static const unsigned short *SCORE_ATTK = SCORE_ATTK_ + 32;
//1880g

 

//1867z
//0,0,0,3,6, 7,9,10,12,15,18,22,27,31,36, 48, 60,63,66,81,96, 120,144,168,192,240, 255,255,255,255,255,255};



//static const unsigned char EG_pawn_bonus[6]={0, 16, 24, 60, 84, 127};   //good for sac10
//static const unsigned char EG_pawn_bonus[6]={0, 12, 24, 60, 84, 127};   //good for sac10
//static const unsigned char EG_pawn_bonus[6]={0, 10, 16, 40, 84, 127};   //good for sac10

//static const char EG_pawn_bonus_[11]={-90, -64, -40, -24, -10, 0, 10, 24, 40, 64, 90};  
//static const char EG_pawn_bonus_[11]={-91, -70, -49, -28, -7, 0, 7, 28, 49, 70, 91};  

//static const char EG_pawn_bonus_[11]={-127, -84, -54, -24, -12, 0, 12, 24, 54, 84, 127};  
//static const char *EG_pawn_bonus = EG_pawn_bonus_ + 5;

static const unsigned char king_defect[BOARD_SIZE-7] = {
0,0,0,1,0,1,0,0,0,  0,0,0,0,0,0,0,
0,0,0,2,2,2,0,0,0,  0,0,0,0,0,0,0,
0,0,0,3,3,3,0,0,0,  0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,

0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,
0,0,0,3,3,3,0,0,0,  0,0,0,0,0,0,0,
0,0,0,2,2,2,0,0,0,  0,0,0,0,0,0,0,
0,0,0,1,0,1,0,0,0};


inline
int Board::Evalattk_R()
{
	int score;
//unsigned int bitpiece = 0; //RrRrCcCc HhHhEeEe BbBbPpPp PpPpPp00
//unsigned char boardsq[34];
//    2,3, 4,5,6,7, 8,9,10,11, 12,13,14,15, 16,17,18,19, 20,21,22,23, 24,25,26,27, 28,29,30,31, 32,33
//    p P  p P p P  p P p  P   b  B  b  B   e  E  e  E   h  H  h  H   c  C  c  C   r  R  r  R   k  K
//static const unsigned char ATTKAREA[BOARD_SIZE-7] = {
/*
6,6,0,0,4,2,2,8,8,  0,0,0,0,0,0,0,
6,6,0,0,4,2,2,8,8,  0,0,0,0,0,0,0,
6,6,0,0,4,2,2,8,8,  0,0,0,0,0,0,0,
6,6,6,6,4,8,8,8,8,  0,0,0,0,0,0,0,
6,6,6,6,4,8,8,8,8,  0,0,0,0,0,0,0,

7,7,7,7,5,9,9,9,9,  0,0,0,0,0,0,0,
7,7,7,7,5,9,9,9,9,  0,0,0,0,0,0,0,
7,7,1,1,5,3,3,9,9,  0,0,0,0,0,0,0,
7,7,1,1,5,3,3,9,9,  0,0,0,0,0,0,0,
7,7,1,1,5,3,3,9,9};
*/
   // three piece attack one side, rook=4, c/n/p=2, defend side+central c/h/e/b central =1
   int num_attk, num_defn, num_attk2, num_defn2; //, advele_defect; //, attkscore;
   int num_halfattk, num_halfattk2, num_quadattk, num_quadattk2;
#ifndef _WIN64
if (POPCNT_CPU)
#endif	
{	 num_attk = PCbitCountRookR(bitattk[0]);
	 num_halfattk = (PCbitCount(bitattk[0] & 0x00A00AA8)) + (PCbitCount(bitattk[4] & 0xAA000AA8))  //red Horse+pawn attack from area[0]	+ central rook+cann+pawn 
	              + (PCbitCountCannR(bitattk[5]));
	 num_quadattk = (PCbitCount((bitattk[6]) & 0xAAA00000));  //red Rook+Cann+Hors attack from area[6] 
/*	 
   num_attk = PCbitCountRookR(bitattk[0]) *4
            + (PCbitCount(bitattk[0] & 0x0AA00AA8)) *2   //red Cann+Horse+Pawn attack from area[0]
            + (PCbitCount((bitattk[4] | bitattk[6]) & 0xAAA00AA8))  //red Rook+Cann+Hors+Pawn attack from area[4] or [6]

//1107 + (PCbitCountRookR((bitattk[7] | bitattk[6]))) *2
            + (PCbitCountRookR(( bitattk[6]))) *2
            + (PCbitCountHorsR(bitattk[6]))
            + (PCbitCountCannR(bitattk[5]));
*/            
   num_defn = PCbitCountRookB(bitattk[0]) *4
   + PCbitCountRookB(bitattk[6])
            + (PCbitCountCHEBB(bitattk[0] | bitattk[4]) /2);
//   int king_rank = (nRank(boardsq[32]) >>1) *4;	         
//1107     int king_offset = (nFile(boardsq[32]) - 4);  // -1, 0, +1  
     //int king7 = king_offset *7; 
     //int kingking3 = king_offset * king_offset *3;
           
   //score = SCORE_ATTK[num_attk - num_defn - (king_offset>0 ? 5 : king_offset*2)]; // + advele_defect];
//1104  score = SCORE_ATTK[num_attk - num_defn - ((7 + 3*king_offset)*king_offset)/2];   
//1107	 score = SCORE_ATTK[num_attk - num_defn + king_defect[boardsq[32]]];       //1104
   //score = SCORE_ATTK[num_attk - num_defn - ((king7 + kingking3)/2)];
   //score = SCORE_ATTK[num_attk - num_defn - (king_offset*3) ];   
   num_attk2 = PCbitCountRookR(bitattk[2]);
	 num_halfattk2 = (PCbitCount(bitattk[2] & 0x00A00AA8)) + (PCbitCount(bitattk[4] & 0xAA000AA8))  //red Horse+pawn attack from area[2]	+ central rook+cann+pawn 
	              + (PCbitCountCannR(bitattk[5]));
	 num_quadattk2 = (PCbitCount((bitattk[8]) & 0xAAA00000));  //red Rook+Cann+Hors attack from area[8] 
/*
   num_attk2 = PCbitCountRookR(bitattk[2]) *4
   + (PCbitCount(bitattk[2] & 0x0AA00AA8)) *2
            + (PCbitCount((bitattk[4] | bitattk[8]) & 0xAAA00AA8))
//1107 + (PCbitCountRookR((bitattk[9] | bitattk[8]))) *2
       + (PCbitCountRookR(( bitattk[8]))) *2
            + (PCbitCountHorsR(bitattk[8]))
            + (PCbitCountCannR(bitattk[5]));
*/            
   num_defn2 = PCbitCountRookB(bitattk[2]) *4
   + PCbitCountRookB(bitattk[8])
            + (PCbitCountCHEBB(bitattk[2] | bitattk[4]));

   //score += SCORE_ATTK[num_attk2 - num_defn + (king_offset<0 ? -5 : king_offset*2)] // + advele_defect]
//1104   score += SCORE_ATTK[num_attk2 - num_defn + ((7 - 3*king_offset)*king_offset)/2] 
//1107         score += SCORE_ATTK[num_attk2 - num_defn2 + king_defect[boardsq[32]]]       //1104 
   //score += SCORE_ATTK[num_attk2 - num_defn + ((king7 - kingking3)/2)] 
   //score += SCORE_ATTK[num_attk2 - num_defn + (king_offset*3) ]
//1107            + (num_attk + num_attk2)/4;

   score = SCORE_ATTK[num_attk*4 + num_halfattk*2 + num_quadattk - num_defn + king_defect[boardsq[32]]];   //1107
   score += BONUS_ATTK[num_attk*4 + num_halfattk*2 + num_quadattk];          //1107      
   score += SCORE_ATTK[num_attk2*4 + num_halfattk2*2 + num_quadattk2 - num_defn2 + king_defect[boardsq[32]]];   //1107
   score += BONUS_ATTK[num_attk2*4 + num_halfattk2*2 + num_quadattk2];          //1107 
//increase score if attk by 2 rooks and king not safe or advele_defect
//1107  if (((num_attk + num_attk2) >=8) 
  	//&& (bitCountEleAdvB(bitpiece) <=2)
//1107  	)
//1107	{
//1107		score += ((nRank(boardsq[32]) ) <<3) * (1-((PCbitCountEleAdvB(bitpiece)+1)>>2)) ;
//1107	}	
  
}

#ifndef _WIN64
else // POPCNT_CPU
{	
   num_attk = bitCountRookR(bitattk[0]) *4

   + (bitCount(bitattk[0] & 0x0AA00AA8)) *2
            + (bitCount((bitattk[4] | bitattk[6]) & 0xAAA00AA8))

+ (bitCountRookR((bitattk[7] | bitattk[6]))) *2

            + (bitCountHorsR(bitattk[6]))
            + (bitCountCannR(bitattk[5]));
   num_defn = bitCountRookB(bitattk[0]) *4
   + bitCountRookB(bitattk[6])
            + (bitCountCHEBB(bitattk[0] | bitattk[4]) /2);
//   int king_rank = (nRank(boardsq[32]) >>1) *4;	         
     int king_offset = (nFile(boardsq[32]) - 4);  // -1, 0, +1  
     //int king7 = king_offset *7; 
     //int kingking3 = king_offset * king_offset *3;
           
   //score = SCORE_ATTK[num_attk - num_defn - (king_offset>0 ? 5 : king_offset*2)]; // + advele_defect];
     score = SCORE_ATTK[num_attk - num_defn - ((7 + 3*king_offset)*king_offset)/2];   

   //score = SCORE_ATTK[num_attk - num_defn - ((king7 + kingking3)/2)];
   //score = SCORE_ATTK[num_attk - num_defn - (king_offset*3) ];   

   num_attk2 = bitCountRookR(bitattk[2]) *4

   + (bitCount(bitattk[2] & 0x0AA00AA8)) *2
            + (bitCount((bitattk[4] | bitattk[8]) & 0xAAA00AA8))

+ (bitCountRookR((bitattk[9] | bitattk[8]))) *2

            + (bitCountHorsR(bitattk[8]))
            + (bitCountCannR(bitattk[5]));
   num_defn = bitCountRookB(bitattk[2]) *4
   + bitCountRookB(bitattk[8])
            + (bitCountCHEBB(bitattk[2] | bitattk[4]));

   //score += SCORE_ATTK[num_attk2 - num_defn + (king_offset<0 ? -5 : king_offset*2)] // + advele_defect]
   score += SCORE_ATTK[num_attk2 - num_defn + ((7 - 3*king_offset)*king_offset)/2] 
   //score += SCORE_ATTK[num_attk2 - num_defn + ((king7 - kingking3)/2)] 
   //score += SCORE_ATTK[num_attk2 - num_defn + (king_offset*3) ]
            + (num_attk + num_attk2)/4;

//increase score if attk by 2 rooks and king not safe or advele_defect
  if (((num_attk + num_attk2) >=8) 
  	//&& (bitCountEleAdvB(bitpiece) <=2)
  	)
	{
		score += ((nRank(boardsq[32]) ) <<3) * (1-((bitCountEleAdvB(bitpiece)+1)>>2)) ;
		
	}	
  //score <<= (5-bitCountEleAdvB(bitpiece))/2;
}
#endif
   
  return score;
}

inline
int Board::Evalattk_B()
{
	int score; //=0;
	int num_attk, num_defn, num_attk2, num_defn2;
	int num_halfattk, num_halfattk2, num_quadattk, num_quadattk2;

#ifndef _WIN64
if (POPCNT_CPU)
#endif	
{	
/*	
   num_attk = PCbitCountRookB(bitattk[1]) *4 + (PCbitCount(bitattk[1] & 0x05500554)) *2
            + (PCbitCount((bitattk[5] | bitattk[7]) & 0x55500554))
//1107 + (PCbitCountRookB((bitattk[6] | bitattk[7]))) *2
+ (PCbitCountRookB(( bitattk[7]))) *2
            + (PCbitCountHorsB(bitattk[7]))
            + (PCbitCountCannB(bitattk[4]));
   num_defn = PCbitCountRookR(bitattk[1]) *4
   + PCbitCountRookR(bitattk[7])
            + (PCbitCountCHEBR(bitattk[1])); // | bitattk[5]));
//   int king_rank = ((9 - nRank(boardsq[33])) >>1) *4;         
//1107   int king_offset = (nFile(boardsq[33]) - 4);  // -1, 0, +1     
   //int king7 = king_offset *7;  
   //int kingking3 = king_offset * king_offset *3;
   //score = SCORE_ATTK[num_attk - num_defn - (king_offset>0 ? 5 : king_offset*2)]; // + advele_defect]; // + 32];
//1104   score = SCORE_ATTK[num_attk - num_defn - ((7 + 3*king_offset)*king_offset)/2];
//1107   score = SCORE_ATTK[num_attk - num_defn + king_defect[boardsq[33]]];       //1104
   //score = SCORE_ATTK[num_attk - num_defn - ((king7 + kingking3)/2)];
   //score = SCORE_ATTK[num_attk - num_defn - (king_offset*3) ];
   num_attk2 = PCbitCountRookB(bitattk[3]) *4 + (PCbitCount(bitattk[3] & 0x05500554)) *2
            + (PCbitCount((bitattk[5] | bitattk[9]) & 0x55500554))
//1107 + (PCbitCountRookB((bitattk[8] | bitattk[9]))) *2
+ (PCbitCountRookB(( bitattk[9]))) *2
            + (PCbitCountHorsB(bitattk[9]))
            + (PCbitCountCannB(bitattk[4]));
   num_defn2 = PCbitCountRookR(bitattk[3]) *4
   + PCbitCountRookR(bitattk[9])
            + (PCbitCountCHEBR(bitattk[3])); // | bitattk[5]));
   //score += SCORE_ATTK[num_attk2 - num_defn + (king_offset<0 ? -5 : king_offset*2)] // + advele_defect] // + 32];
//1104   score += SCORE_ATTK[num_attk2 - num_defn + ((7 - 3*king_offset)*king_offset)/2] 
//1107   score += SCORE_ATTK[num_attk2 - num_defn2 + king_defect[boardsq[33]]]       //1104 
   //score += SCORE_ATTK[num_attk2 - num_defn + ((king7 - kingking3)/2)] 
   //score += SCORE_ATTK[num_attk2 - num_defn + (king_offset*3) ]
//1107            + (num_attk + num_attk2)/4;
*/   
   num_attk = PCbitCountRookB(bitattk[1]);
	 num_halfattk = (PCbitCount(bitattk[1] & 0x00500554)) + (PCbitCount(bitattk[5] & 0x55000554))  //black Horse+pawn attack from area[0]	+ central rook+cann+pawn 
	              + (PCbitCountCannB(bitattk[4]));
	 num_quadattk = (PCbitCount((bitattk[7]) & 0x55500000));  //black Rook+Cann+Hors attack from area[7] 
	 
	 num_defn = PCbitCountRookR(bitattk[1]) *4
   + PCbitCountRookR(bitattk[7])
            + (PCbitCountCHEBR(bitattk[1])); // | bitattk[5]));
            
	 num_attk2 = PCbitCountRookB(bitattk[3]);
	 num_halfattk2 = (PCbitCount(bitattk[3] & 0x00500554)) + (PCbitCount(bitattk[5] & 0x55000554))  //black Horse+pawn attack from area[3]	+ central rook+cann+pawn 
	              + (PCbitCountCannB(bitattk[4]));
	 num_quadattk2 = (PCbitCount((bitattk[9]) & 0x55500000));  //black Rook+Cann+Hors attack from area[9] 
	 
	 num_defn2 = PCbitCountRookR(bitattk[3]) *4
   + PCbitCountRookR(bitattk[9])
            + (PCbitCountCHEBR(bitattk[3])); // | bitattk[5]));
            
   score = SCORE_ATTK[num_attk*4 + num_halfattk*2 + num_quadattk - num_defn + king_defect[boardsq[33]]];   //1107
   score += BONUS_ATTK[num_attk*4 + num_halfattk*2 + num_quadattk];          //1107      
   score += SCORE_ATTK[num_attk2*4 + num_halfattk2*2 + num_quadattk2 - num_defn2 + king_defect[boardsq[33]]];   //1107
   score += BONUS_ATTK[num_attk2*4 + num_halfattk2*2 + num_quadattk2];          //1107 
//increase score if attk by 2 rooks and king not safe or advele_defect
//1107  if (((num_attk + num_attk2) >=8) 
  	//&& (bitCountEleAdvR(bitpiece) <=2)
//1107  	)
//1107	{
//1107		score += ((9 - nRank(boardsq[33])) <<3) * (1-((PCbitCountEleAdvR(bitpiece)+1)>>2)) ;
//1107	}
  //score <<= (5-bitCountEleAdvR(bitpiece))/2;
}
#ifndef _WIN64
else //POPCNT_CPU

{	
   num_attk = bitCountRookB(bitattk[1]) *4 + (bitCount(bitattk[1] & 0x05500554)) *2
            + (bitCount((bitattk[5] | bitattk[7]) & 0x55500554))

+ (bitCountRookB((bitattk[6] | bitattk[7]))) *2
            + (bitCountHorsB(bitattk[7]))
            + (bitCountCannB(bitattk[4]));
   num_defn = bitCountRookR(bitattk[1]) *4
   + bitCountRookR(bitattk[7])
            + (bitCountCHEBR(bitattk[1])); // | bitattk[5]));
//   int king_rank = ((9 - nRank(boardsq[33])) >>1) *4;         
   int king_offset = (nFile(boardsq[33]) - 4);  // -1, 0, +1     
   //int king7 = king_offset *7;  
   //int kingking3 = king_offset * king_offset *3;
      
   //score = SCORE_ATTK[num_attk - num_defn - (king_offset>0 ? 5 : king_offset*2)]; // + advele_defect]; // + 32];
   score = SCORE_ATTK[num_attk - num_defn - ((7 + 3*king_offset)*king_offset)/2];
   //score = SCORE_ATTK[num_attk - num_defn - ((king7 + kingking3)/2)];
   
   //score = SCORE_ATTK[num_attk - num_defn - (king_offset*3) ];


   num_attk2 = bitCountRookB(bitattk[3]) *4 + (bitCount(bitattk[3] & 0x05500554)) *2
            + (bitCount((bitattk[5] | bitattk[9]) & 0x55500554))

+ (bitCountRookB((bitattk[8] | bitattk[9]))) *2
            + (bitCountHorsB(bitattk[9]))
            + (bitCountCannB(bitattk[4]));
   num_defn = bitCountRookR(bitattk[3]) *4
   + bitCountRookR(bitattk[9])
            + (bitCountCHEBR(bitattk[3])); // | bitattk[5]));

   //score += SCORE_ATTK[num_attk2 - num_defn + (king_offset<0 ? -5 : king_offset*2)] // + advele_defect] // + 32];
   score += SCORE_ATTK[num_attk2 - num_defn + ((7 - 3*king_offset)*king_offset)/2] 
   //score += SCORE_ATTK[num_attk2 - num_defn + ((king7 - kingking3)/2)] 
   //score += SCORE_ATTK[num_attk2 - num_defn + (king_offset*3) ]
            + (num_attk + num_attk2)/4;

//increase score if attk by 2 rooks and king not safe or advele_defect
  if (((num_attk + num_attk2) >=8) 
  	//&& (bitCountEleAdvR(bitpiece) <=2)
  	)
	{
		score += ((9 - nRank(boardsq[33])) <<3) * (1-((bitCountEleAdvR(bitpiece)+1)>>2)) ;
		
	}
  //score <<= (5-bitCountEleAdvR(bitpiece))/2;
}	
#endif  
   return score;
}


//一般来说，黑方肯定可守和的残局，mul[white]会设定为1，即是将白方优势除以16
//至于黑方很有机会和的残局，则将mul[white]设定为8，即是即是将白方优势除以2.
//什么叫肯定会和？例如帅仕相全对将双士
//什么叫很可能会和？例如马炮仕相全对马炮士象全
unsigned char eg_mul[4][4][4][4][5][5] = {
// B_pawncnt==0  R_pawncnt==0  B_rook_cnt==0   R_rook_cnt==0
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA                B  R  B  R    
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA                C  C  H  H
{{{{{1,1,1,1,1     }, {1,1,1,1,1     }, {1,1,1,1,1     }, {1,1,1,1,1     }, {1,1,1,1,1     }}, //[0][0][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {4,4,4,4,4     }, {1,1,1,1,1     }, {1,1,1,1,1     }}, //[0][0][0][1] //士象和单马
{{16,16,4,2,1   }, {16,16,4,2,1   }, {16,16,4,2,1   }, {16,16,4,2,1   }, {16,16,4,2,1   }}, //[0][0][1][0] //单马和仕相
{{4,4,4,4,4     }, {4,4,4,4,4     }, {4,4,4,4,4     }, {4,4,4,4,4     }, {4,4,4,4,4     }}}, //[0][0][1][1] //单马和单马

{{{1,16,16,16,16 }, { 1,16,16,16,16}, {1,16,16,16,16 }, {1,16,16,16,16 }, {1,4,4,4,4     }}, //[0][1][0][0] //士象和单炮
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][1]
{{8,8,8,8,8}, {8,8,8,8,8}, {8,8,8,8,8}, {8,8,8,8,8}, {8,8,8,8,4 }}, //[0][1][1][0] //单炮和单马
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{1,1,1,1,1     }, {16,16,16,16,4 }, {16,16,16,16,4 }, {16,16,16,16,4 }, {16,16,16,16,4 }}, //[1][0][0][0] //单炮和仕相
{{8,8,8,8,8}, {8,8,8,8,8}, {8,8,8,8,8}, {8,8,8,8,8}, {8,8,8,8,4 }}, //[1][0][0][1] //单马和单炮
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{1,12,12,12,12}, {12,12,12,12,12}, {12,12,12,12,12}, {12,12,12,8,8 }, {12,12,12,8,4 }}, //[1][1][0][0] //单炮和单炮
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,8,10 }, {16,16,16,10,8 }}}}, //[1][1][1][1] //马炮仕相全和马炮士象全

// B_pawncnt==0  R_pawncnt==0  B_rook_cnt == 0   R_rook_cnt == 1
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {4,4,4,4,4     }}, //[0][0][0][0] //士相全和单车
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][0][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {1,1,1,1,1     }}, //[0][0][1][0] //单炮士相全和单车
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {1,1,1,1,1     }}, //[1][0][0][0] //单马士相全和单车
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {1,1,1,1,1     }}, //[1][0][1][0] //马炮士相全和单车
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}, //[1][1][1][1]

// B_pawncnt==0  R_pawncnt==0  B_rook_cnt == 1   R_rook_cnt == 0
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{16,16,16,16,4 }, {16,16,16,16,2 }, {16,16,16,16,4 }, {16,16,16,16,4 }, {16,16,16,16,4 }}, //[0][0][0][0] //单车和士相全
{{16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }}, //[0][0][0][1] //单车和单炮士相全
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][0][1][1]

{{{16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }}, //[0][1][0][0] //单车和单马士相全
{{16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }}, //[0][1][0][1] //单车和炮马士相全
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}, //[1][1][1][1]

// B_pawncnt==0  R_pawncnt==0  B_rook_cnt == 1   R_rook_cnt == 1                     BCH RC
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{8,8,8,8,8     }, {8,8,8,8,8     }, {8,8,8,8,8     }, {8,8,8,8,8     }, {8,8,8,8,8     }}, //[0][0][0][0] //单车和单车
{{4,4,4,4,4     }, {6,6,6,6,6     }, {7,7,7,7,7     }, {8,8,8,8,8     }, {1,1,1,1,1     }}, //[0][0][0][1] //车对车马
{{4,6,7,8,1     }, {4,6,7,8,1     }, {4,6,7,8,1     }, {4,6,7,8,1     }, {4,6,7,8,1     }}, //[0][0][1][0] //车马对车
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,2,4  }, {16,16,16,4,2  }}}, //[0][0][1][1] //车马对车马

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,12,12,12}, {16,16,12,12,12}, {4,4,4,4,4 }}, //[0][1][0][0] //车仕相全对车炮士象全,一般和，有巧胜
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][1] //
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,4}, {16,16,16,16,4}, {16,16,12,12,4}, {16,16,12,12,4}, {16,16,12,12,4,}}, //[1][0][0][0] //车炮仕相全对车士象全,一般和，有巧胜
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][1] //
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{ 8,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,8 }, {16,16,16,8,8  }}, //[1][1][0][0] //车炮对车炮
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1] //
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}}, //[1][1][1][1]
//------------------------------------------------

//  B_pawncnt==0  R_pawncnt==1  B_rook_cnt == 0   R_rook_cnt == 0
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{{16,16,16,16,16}, {10,10,10,10,10}, {1,1,1,1,1     }, {1,1,1,1,1      },{1,1,1,1,1     }}, //[0][0][0][0] //兵
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, { 10,10,10,10,10},{ 8,8,8,8,8    }},  //[0][0][0][1] //士象和单马兵
{{4,2,2,1,1     }, {4,2,2,1,1     }, {4,2,2,1,1     }, {4,2,2,1,1      },{4,2,2,1,1     }}, //[0][0][1][0] //单马和仕相兵
{{16,16,16,16,16}, {4,4,4,4,4     }, {4,4,4,4,4     }, {4,4,4,4,4      },{4,4,4,4,4     }}}, //[0][0][1][1] //单马和单马兵

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16 },{4,4,4,16,16   }}, //[0][1][0][0] //士象和单炮兵
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}}, //[0][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {8,8,8,8,8     }, {2,2,2,2,2      },{1,1,1,1,1     }}, //[0][1][1][0] //单炮和单马兵
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}}}, //[0][1][1][1]

{{{1,1,1,1,1     }, {4,2,1,1,1     }, {4,2,1,1,1     }, {4,2,1,1,1      },{4,2,1,1,1     }}, //[1][0][0][0] //单炮和仕相兵
{{16,16,16,16,16}, {4,4,4,4,4     }, {4,4,4,4,4     }, {4,4,4,4,4      },{4,4,4,4,4     }}, //[1][0][0][1] //单马和单炮兵
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}}, //[1][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}}}, //[1][0][1][1]

{{{1,16,16,16,16 }, {4,8,8,8,8     }, {4,4,4,4,4     }, {4,4,4,4,4      },{4,4,4,4,4     }}, //[1][1][0][0] //单炮和单炮兵
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}}, //[1][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}}}},  //[1][1][1][1] //马炮仕相全VS马炮士象全兵

// B_pawncnt==0  R_pawncnt==1  B_rook_cnt == 0   R_rook_cnt == 1
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][0][0][0] //士相全负单车兵
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][0][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {10,10,10,10,10}}, //[0][0][1][0] //单炮士相全和单车兵
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {10,10,10,10,10}}, //[1][0][0][0] //单马士相全和单车兵
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {8,8,8,8,8     }}, //[1][0][1][0] //马炮士相全和单车兵
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}, //[1][1][1][1]

// B_pawncnt==0  R_pawncnt==1  B_rook_cnt == 1   R_rook_cnt == 0
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{16,16,16,16,4 }, {16,16,16,16,4 }, {16,16,16,16,4 }, {16,16,16,16,4 }, {16,16,16,16,4 }}, //[0][0][0][0] //单车和士相全兵
{{16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }}, //[0][0][0][1] //单车和单炮士相全兵
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][0][1][1]

{{{16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }}, //[0][1][0][0] //单车和单马士相全兵
{{16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }}, //[0][1][0][1] //单车和炮马士相全兵
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}, //[1][1][1][1]

// B_pawncnt==0  R_pawncnt==1  B_rook_cnt == 1   R_rook_cnt == 1                     BCH RC
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{16,16,16,16,16}, {16,16,16,16,16 },{8,8,8,8,8     }, {8,8,8,8,8     }, {8,8,8,8,8     }}, //[0][0][0][0] //单车对单车兵
{{16,16,16,16,16}, { 16,16,16,16,16},{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][0][0][1] //车对车马兵
{{4,6,7,8,1     }, {4,6,7,8,1      },{4,6,7,8,1     }, {4,6,7,8,1     }, {4,6,7,8,1     }}, //[0][0][1][0] //车马对车兵
{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,2,4  }, {16,16,16,4,2  }}}, //[0][0][1][1] //车马对车马兵

{{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,4 }}, //[0][1][0][0] //车仕相全对车炮士象全兵,一般和，有巧胜
{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][1] //
{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,4 }}, //[1][0][0][0] //车炮仕相全对车士象全兵,一般和，有巧胜
{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][1] //
{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,16,16}, {8,8,8,8,8     }}, //[1][1][0][0] //车炮对车炮兵
{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1] //
{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16 },{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}}, //[1][1][1][1]
//------------------------------------------------

//  B_pawncnt==1  R_pawncnt==0  B_rook_cnt == 0   R_rook_cnt == 0
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{{16,10,1,1,1   }, {16,10,1,1,1   }, {16,10,1,1,1   }, {16,10,1,1,1   }, {16,10,1,1,1   }}, //[0][0][0][0] //卒
{{4,4,4,4,4     }, {2,2,2,2,2     }, {2,2,2,2,2     }, {1,1,1,1,1     }, {1,1,1,1,1     }}, //[0][0][0][1] //士象卒和单马
{{16,16,16,10,8 }, {16,16,16,10,8 }, {16,16,16,10,8 }, {16,16,16,10,8 }, {16,16,16,10,8 }}, //[0][0][1][0] //单马卒和仕相
{{16,4,4,4,4    }, {16,4,4,4,4    }, {16,4,4,4,4    }, {16,4,4,4,4    }, {16,4,4,4,4    }}}, //[0][0][1][1] //单马卒和单马

{{{1,4,4,4,4     }, {1,2,2,2,2     }, {1,1,1,1,1     }, {1,1,1,1,1     }, {1,1,1,1,1     }}, //[0][1][0][0] //士象卒和单炮
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][1]
{{16,4,4,4,4    }, {16,4,4,4,4    }, {16,4,4,4,4    }, {16,4,4,4,4    }, {16,4,4,4,4    }}, //[0][1][1][0] //单炮卒和单马
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,4 }, {16,16,16,16,4 }, {16,16,16,16,4 }, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][0] //单炮卒和仕相
{{16,16,8,2,1   }, {16,16,8,2,1   }, {16,16,8,2,1   }, {16,16,8,2,1   }, {16,16,8,2,1   }}, //[1][0][0][1] //单马卒和单炮
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{1,4,4,4,4     }, {16,8,4,4,4    }, {16,8,4,4,4    }, {16,8,4,4,4    }, {16,8,4,4,4    }}, //[1][1][0][0] //单炮卒和单炮
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}, //[1][1][1][1] //马炮仕相全卒VS马炮士象全

// B_pawncnt==1  R_pawncnt==0  B_rook_cnt == 0   R_rook_cnt == 1
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {4,4,4,4,4     }}, //[0][0][0][0] //士相全卒和单车
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][0][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {1,1,1,1,1     }}, //[0][0][1][0] //单炮士相全卒和单车
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {1,1,1,1,1     }}, //[1][0][0][0] //单马士相全卒和单车
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {1,1,1,1,1     }}, //[1][0][1][0] //马炮士相全卒和单车
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}, //[1][1][1][1]

// B_pawncnt==1  R_pawncnt==0  B_rook_cnt == 1   R_rook_cnt == 0
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][0][0][0] //单车卒胜士相全
{{16,16,16,16,10}, {16,16,16,16,10}, {16,16,16,16,10}, {16,16,16,16,10}, {16,16,16,16,10}}, //[0][0][0][1] //单车卒和单炮士相全
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][0][1][1]

{{{16,16,16,16,10}, {16,16,16,16,10}, {16,16,16,16,10}, {16,16,16,16,10}, {16,16,16,16,10}}, //[0][1][0][0] //单车卒和单马士相全
{{16,16,16,16,8 }, {16,16,16,16,8 }, {16,16,16,16,8 }, {16,16,16,16,8 }, {16,16,16,16,8 }}, //[0][1][0][1] //单车卒和炮马士相全
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}, //[1][1][1][1]

// B_pawncnt==1  R_pawncnt==0  B_rook_cnt == 1   R_rook_cnt == 1                     BCH RC
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{16,16,8,8,8   }, {16,16,8,8,8   }, {16,16,8,8,8   }, {16,16,8,8,8   }, {16,16,8,8,8   }}, //[0][0][0][0] //单车卒和单车
{{4,4,4,4,4     }, {6,6,6,6,6     }, {7,7,7,7,7     }, {8,8,8,8,8     }, {1,1,1,1,1     }}, //[0][0][0][1] //车卒对车马
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][0][1][0] //车马卒对车
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,2,4  }, {16,16,16,4,2  }}}, //[0][0][1][1] //车马卒对车马

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,4 }}, //[0][1][0][0] //车仕相全卒对车炮士象全,一般和，有巧胜
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][1] //
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,4 }}, //[1][0][0][0] //车炮仕相全卒对车士象全,一般和，有巧胜
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][1] //
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{16,16,16,16,8 }, {16,16,16,16,8 }, {16,16,16,16,8 }, {16,16,16,16,8 }, {16,16,16,16,8 }},  //[1][1][0][0] //车炮卒对车炮
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1] //
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}}, //[1][1][1][1]
//------------------------------------------------

//  B_pawncnt==1  R_pawncnt==1  B_rook_cnt == 0   R_rook_cnt == 0
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{{1,1,1,1,1     }, {1,1,1,1,1     }, {1,1,1,1,1     }, {1,1,1,1,1     }, {1,1,1,1,1     }}, //[0][0][0][0] //单兵  单卒
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {8,8,8,8,8     }, {1,1,1,1,1     }}, //[0][0][0][1] //士象兵和单马卒
{{16,16,16,8,1  }, {16,16,16,8,1  }, {16,16,16,8,1  }, {16,16,16,8,1  }, {16,16,16,8,1  }},  //[0][0][1][0] //单马兵和仕相卒
{{4,4,4,4,4     }, {4,4,4,4,4     }, {4,4,4,4,4     }, {4,4,4,4,4     }, {4,4,4,4,4     }}}, //[0][0][1][1] //单马兵和单马卒

{{{1,16,16,16,16 }, { 1,16,16,16,16}, {1,16,16,16,16 }, {1,16,16,16,16 }, {1,4,4,4,4     }}, //[0][1][0][0] //士象兵和单炮卒
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,4 }}, //[0][1][1][0] //单炮兵和单马卒
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,8,4, }, {16,16,16,8,4  }, {16,16,16,8,4  }, {16,16,16,8,4  }, {16,16,16,8,4  }}, //[1][0][0][0] //单炮兵和仕相卒
{{16,16,16,16,16}, {16,16,8,8,4   }, {16,16,8,8,4   }, {16,16,8,8,4   }, {16,16,8,8,4   }}, //[1][0][0][1] //单马兵和单炮卒
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{16,16,16,16,16}, {16,16,8,8,4   }, {16,16,8,8,4   }, {16,16,8,8,4   }, {16,16,8,8,4   }}, //[1][1][0][0] //单炮兵和单炮卒
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}},  //[1][1][1][1] //马炮仕相全兵VS马炮士象全卒

// B_pawncnt==1  R_pawncnt==1  B_rook_cnt == 0   R_rook_cnt == 1
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}},      //[0][0][0][0] //士相全兵和单车卒
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][0][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {8,8,8,8,8     }}, //[0][0][1][0] //单炮士相全兵和单车卒
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {10,10,10,10,10}},      //[1][0][0][0] //单马士相全和单车卒
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {1,1,1,1,1     }}, //[1][0][1][0] //马炮士相全和单车卒
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}, //[1][1][1][1]

// B_pawncnt==1  R_pawncnt==1  B_rook_cnt == 1   R_rook_cnt == 0
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}},  //[0][0][0][0] //单车和士相全
{{16,16,16,16,8 }, {16,16,16,16,8 }, {16,16,16,16,8 }, {16,16,16,16,8 }, {16,16,16,16,8 }}, //[0][0][0][1] //单车和单炮士相全
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][0][1][1]

{{{16,16,16,16,10}, {16,16,16,16,10}, {16,16,16,16,10}, {16,16,16,16,10}, {16,16,16,16,10}},  //[0][1][0][0] //单车和单马士相全
{{16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }, {16,16,16,16,1 }}, //[0][1][0][1] //单车和炮马士相全
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}, //[1][1][1][1]

// B_pawncnt==1  R_pawncnt==1  B_rook_cnt == 1   R_rook_cnt == 1                     BCH RC
//0 0 0 0 0     1 1 1 1 1       2 2 2 2 2       3 3 3 3 3       4 4 4 4 4 <-BEA
//0 1 2 3 4     0 1 2 3 4       0 1 2 3 4       0 1 2 3 4       0 1 2 3 4 <-REA
{{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,8,8,8   }, {16,16,8,8,8   }, {16,16,8,8,8   }},   //[0][0][0][0] //单车和单车
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,8,8  }, {16,16,16,8,8  }, {16,16,16,8,8  }},    //[0][0][0][1] //车对车马
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,8,8  }, {16,16,16,8,8  }, {16,16,16,8,8  }},    //[0][0][1][0] //车马对车
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,8,8  }, {16,16,16,8,8  }, {16,16,16,8,8  }}}, //[0][0][1][1] //车马对车马

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,8 }}, //[0][1][0][0] //车仕相全对车炮士象全,一般和，有巧胜
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][0][1] //
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[0][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[0][1][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}},  //[1][0][0][0] //车炮仕相全对车士象全,一般和，有巧胜
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][0][1] //
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][0][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}, //[1][0][1][1]

{{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,8,8  }, { 16,16,16,8,8 }, {16,16,16,8,8  }}, //[1][1][0][0] //车炮对车炮
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][0][1] //
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}, //[1][1][1][0]
{{16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}, {16,16,16,16,16}}}}}
};//[1][1][1][1]
//------------------------------------------------
#define  score1poscolor 10   //1105
#define  score2poscolor 20
#define  score4poscolor 40
#define  score8poscolor 80
#define  score16poscolor 211 // 190 //175 210  //1111 160
#define  score32poscolor 330        //1111 320
#define  score64poscolor 631 // 630 //1111 640
#define PHASE_MIDGAME 46 //11 (1880xz) //14 //12 (1880y)
#define PHASE_ENDGAME 20 //5 (1880xz)  //8  /
    //Rook=2, Cann,Hors=1, max=2*(2+1+1)*2 = 16
    //Rook=6, Cann,Hors=3, Ele/Bis/Pawn=1, max=2*(6+3+3)*2 + (2+2+5)*2 = 48 + 18 = 66
int Board::Eval()
{
	int score = 0;
	//RCH_count += bitCount(bitpiece & 0x000ffffc); //E+B+P max 18
    //1108 RCH_count = (RCH_count * 3) + bitCount16((bitpiece & 0x000ffff0)>>4); //E+B+P max 16
    //1108 RXHEBP_count(max 66) = rookcount * 4(max 32) + cannhorscount * 2(max 16) + EBP count (max 18)
    int RCHEBP_count = PCbitCount(bitpiece & 0xf0000000) * 4 + PCbitCount(bitpiece & 0x0ff00000) * 2
                     + PCbitCount(bitpiece & 0x000ffffc); 
    if (RCHEBP_count < PHASE_MIDGAME && RCHEBP_count > PHASE_ENDGAME)
    {
    	int eg_pointsum = 0;
      for (int i=2; i<34; i++) //i+=2)
      {
        int sq = boardsq[i];
        if (NOTSQEMPTY(sq))
        {
            eg_pointsum += eg_pointtable[PIECE_IDX(i)][nRank(sq)][nFile(sq)];
        }
      }
      score += (pointsum * RCHEBP_count + eg_pointsum * (66-RCHEBP_count)) / 66;
    }
    else
    	score += pointsum;
    	
	if (PCbitCount(bitpiece & 0xfff00000) <=2) //(PCbitCountRCHRCH <= 2) //1113 (p_endgame==1)   //1105
  {
  	//1113 debug eg rook bug
  	
  	int egk_score=endgameKnowledge();
  	
	  score += egk_score;
	  
	  int ret_score = (m_side ? -score : score + TEMPO_BONUS); //5 3dc92 =7);
//	  if (ret_score==0) printf("*** endgameknowlege score=%d, ret_score=%d\n", egk_score, ret_score);	
	  return ret_score;	
  }
    bitpiece_attk = 0;  //bits attacked for eval rook fork (bitset in EvalHorsPawn and Evalside) 

    //score = EvalSide<0>() - EvalSide<1>(); 
//1113	score += EvalHorsPawn<0>() - EvalHorsPawn<1>();
//1113		+ EvalKingSafety<0>() - EvalKingSafety<1>();
           
		evalthreat[0] = Evalattk_B() + EvalSide<0>();
    evalthreat[1] = Evalattk_R() + EvalSide<1>();


score += evalthreat[0] - evalthreat[1];

// bonus if 2 rooks are forked 
//score += (bitCount(bitpiece_attk & 0xa0000002) >>1) <<6;  // /2) *64;
//score -= (bitCount(bitpiece_attk & 0x50000001) >>1) <<6;  // /2) *64;
//1108 if (bitCountGT1(bitpiece_attk & 0xa0000002))
//1108	score += score64poscolor;
//1108 if (bitCountGT1(bitpiece_attk & 0x50000001))
//1108	score -= score64poscolor;	

/*
// bonus if 2 rooks are forked 
if ((bitpiece_attk & 0xa0000000) == 0xa0000000) 
{	
	score +=64;
#ifdef PRTBOARD
print_board(score);
#endif	
}	

else if ((bitpiece_attk & 0x50000000) == 0x50000000) 
{	
	score -=64;	
#ifdef PRTBOARD
print_board(score);
#endif	
}	
// bonus if rook and king are forked	
else if ((bitpiece_attk & 0x80000002) == 0x80000002) 
	score +=64;	
else if ((bitpiece_attk & 0x40000001) == 0x40000001) 
	score -=64;		
else if ((bitpiece_attk & 0x20000002) == 0x20000002) 
	score +=64;		
else if ((bitpiece_attk & 0x10000001) == 0x10000001) 
	score -=64;	
*/	
    	
   return (m_side ? -score : score + TEMPO_BONUS); //5 3dc92 =7);
}

int Board::endgameKnowledge()
{
	int score = 0;
//board pos
// 0  1  2  3  4  5  6  7  8
// 16 17 18 19 20 21 22 23 24
// 32 33 34 35 36 37 38 39 40
// 48 49 50 51 52 53 54 55 56
// 64 65 66 67 68 69 70 71 72
//
// 80 81 82 83 84 85 86 87 88
// 96 97 98 99 100 1 02 03 04
//112 13 14 15 116 7 18 19 20
//128 29 30 31 132 3 34 35 36
//144 45 46 47 148 9 50 51 52
//endgame knowledge
//1113 temp suppress eg knowledge to debug egrook bug
//goto eval_end;  //1113
  
  	int B_pawncnt, R_pawncnt; 
  	int B_canncnt, R_canncnt, B_rookcnt, R_rookcnt, B_horscnt, R_horscnt;
#ifndef _WIN64  	
  	if (POPCNT_CPU)
#endif  		
    {    	  	
 B_pawncnt = PCbitCountPawnB(bitpiece); //bitCount16(bitpiece & 0x00000554);
 R_pawncnt = PCbitCountPawnR(bitpiece); //bitCount16(bitpiece & 0x00000AA8);
 B_canncnt = PCbitCountCannB(bitpiece);
 R_canncnt = PCbitCountCannR(bitpiece);
 B_rookcnt = PCbitCountRookB(bitpiece);
 R_rookcnt = PCbitCountRookR(bitpiece);
 B_horscnt = PCbitCountHorsB(bitpiece);
 R_horscnt = PCbitCountHorsR(bitpiece);
    }	
#ifndef _WIN64    
	  else // POPCNT_CPU
	  {
 B_pawncnt = bitCountPawnB(bitpiece); //bitCount16(bitpiece & 0x00000554);
 R_pawncnt = bitCountPawnR(bitpiece); //bitCount16(bitpiece & 0x00000AA8);
 B_canncnt = bitCountCannB(bitpiece);
 R_canncnt = bitCountCannR(bitpiece);
 B_rookcnt = bitCountRookB(bitpiece);
 R_rookcnt = bitCountRookR(bitpiece);	 
 B_horscnt = bitCountHorsB(bitpiece);
 R_horscnt = bitCountHorsR(bitpiece); 	

 //B_canncnt = piececnt[B_CANNON1];
 //R_canncnt = piececnt[R_CANNON1];
 //B_rookcnt = piececnt[B_ROOK1];
 //R_rookcnt = piececnt[R_ROOK1];
 //B_horscnt = piececnt[B_HORSE1];
 //R_horscnt = piececnt[R_HORSE1];	
	  }	
#endif	  
  	//printf("info piececnt[B_CANNON1]=%d, piececnt[R_CANNON1]=%d, bitpiece=%X\d", piececnt[B_CANNON1], piececnt[R_CANNON1], bitpiece);
  	// kck - 1 cannon (no advisor) vs king --- draw
//if ( ((piececnt[B_CANNON1] == 1 
if ( ((B_canncnt == 1 	
&& (bitpiece & 0x50505554)==0) // no advisor
&& ((bitpiece & 0xAAA00AA8)==0)) //king w/wo eleadv
||
//   ((piececnt[R_CANNON1] == 1 
     ((R_canncnt == 1 
&& (bitpiece & 0xA0A0AAA8)==0) // no advisor
&& ((bitpiece & 0x55500554)==0)) ) //king w/wo eleadv
{
//#ifdef PRTBOARD
//print_board(score);
//#endif
	score /= 16; //draw
//#ifdef PRTBOARD
//print_bonus(score);
//#endif
goto eval_end;
}
  	int BkingFile = nFile(boardsq[32]);
  	int WkingFile = nFile(boardsq[33]);
  	
//1892m - seabotmoon 海底撈月  


if ((bitpiece & 0x00faaffc) == 0)  // only rook/cannon left, opt Black elebis
{
	if (B_rookcnt == 1 && B_canncnt == 1 
	 && R_rookcnt == 1 && R_canncnt == 0)  
    {
		  if (nFile(boardsq[R_ROOK1])==4 || nFile(boardsq[R_ROOK2])==4) // central RookR - probably draw
			{score /= 8;
//#ifdef PRTBOARD
//print_board(score);
//printf("info boardsq[R_ROOK1]=%d,nFile=%d  boardsq[R_ROOK2]=%d,nFile=%d\n", boardsq[R_ROOK1],nFile(boardsq[R_ROOK1]), boardsq[R_ROOK2],nFile(boardsq[R_ROOK2]));
//#endif					
			goto eval_end;
      }
//#ifdef PRTBOARD
//print_board(score);
//printf("info bitpiece=%X\n", bitpiece);
//#endif		 		 		
		if (BkingFile == 4 // central king
		&& nFile(boardsq[B_ELEPHAN1])!=4 && nFile(boardsq[B_ELEPHAN2])!=4
		&& nFile(boardsq[B_ADVISOR1])!=4 && nFile(boardsq[B_ADVISOR2])!=4
		&& nFile(boardsq[B_CANNON1])!=4 && nFile(boardsq[B_CANNON2])!=4
		)
		switch(WkingFile)
		{
			case 3:
			case 5:					
				if (nFile(boardsq[B_ROOK1])==4 || nFile(boardsq[B_ROOK2])==4) // central RookB
				{score += 32;
					int cann_rank;
					if (NOTSQEMPTY(boardsq[B_CANNON1]))
						   cann_rank = nRank(boardsq[B_CANNON1]);
					else cann_rank = nRank(boardsq[B_CANNON2]);
//#ifdef PRTBOARD
//print_board(score);
//printf("info cann_rank=%d\n", cann_rank);
//#endif
					if (cann_rank<=1)	// discourage cannon back home			
				     score -= 32;	
					if (cann_rank==9)	// cannon to bottom			
				     score += 32;
					if ((boardsq[B_CANNON1])==144 + WkingFile || (boardsq[B_CANNON2])==144 + WkingFile)	//cannon under oppking			
				     score += 32;	
				
			  if ((4-nFile(boardsq[B_CANNON1]))*(4-WkingFile) > 0 || (4-nFile(boardsq[B_CANNON2]))*(4-WkingFile) > 0) // cannon same side as opp king				
			  	score += 32;
				}	
				break;					
	  }
	  goto eval_end;
	}


}

if	((bitpiece & 0x00f55ffc) == 0)  // only rook/cannon left, opt white elebis
{
	if (R_rookcnt == 1 && R_canncnt == 1 
	 && B_rookcnt == 1 && B_canncnt == 0) 	
    {	
		  if (nFile(boardsq[B_ROOK1])==4 || nFile(boardsq[B_ROOK2])==4) // central RookB - probably draw
			{score /= 8;
//#ifdef PRTBOARD
//print_board(score);
//printf("info boardsq[B_ROOK1]=%d,nFile=%d  boardsq[B_ROOK2]=%d,nFile=%d\n", boardsq[B_ROOK1],nFile(boardsq[B_ROOK1]), boardsq[B_ROOK2],nFile(boardsq[B_ROOK2]));
//#endif				
			goto eval_end;
      }
//#ifdef PRTBOARD
//print_board(score);
//printf("info bitpiece=%X\n", bitpiece);
//#endif		 
		 if (WkingFile == 4 // central king
		&& nFile(boardsq[R_ELEPHAN1])!=4 && nFile(boardsq[R_ELEPHAN2])!=4
		&& nFile(boardsq[R_ADVISOR1])!=4 && nFile(boardsq[R_ADVISOR2])!=4
		&& nFile(boardsq[R_CANNON1])!=4 && nFile(boardsq[R_CANNON2])!=4
		)
		switch(BkingFile)
		{
			case 3:
			case 5:					
				if (nFile(boardsq[R_ROOK1])==4 || nFile(boardsq[R_ROOK2])==4) // central RookR
				{score -= 32;
					int cann_rank;
					if (NOTSQEMPTY(boardsq[R_CANNON1]))
						   cann_rank = nRank(boardsq[R_CANNON1]);
					else cann_rank = nRank(boardsq[R_CANNON2]);
//#ifdef PRTBOARD
//print_board(score);
//printf("info cann_rank=%d\n", cann_rank);
//#endif						
					if (cann_rank>=8)	// discourage cannon back home			
				     score += 32;	
					if (cann_rank==0)	// cannon to bottom			
				     score -= 32;					
					if ((boardsq[R_CANNON1])== BkingFile || (boardsq[R_CANNON2])== BkingFile)	//cannon under oppking				
				     score -= 32;											
							 
			  if ((4-nFile(boardsq[R_CANNON1]))*(4-BkingFile) > 0 || (4-nFile(boardsq[R_CANNON2]))*(4-BkingFile) > 0) // cannon same side as opp king				
			    	score -= 32;
				}    	
				break;					
	  }
goto eval_end;	  
	}


} 	
	

  	
  	//  int B_pawncnt = piececnt[B_PAWN0]+piececnt[B_PAWN2]+piececnt[B_PAWN4];
//int B_pawncnt = bitCountPawnB(bitpiece); //bitCount16(bitpiece & 0x00000554);
    //	int R_pawncnt = piececnt[R_PAWN0]+piececnt[R_PAWN2]+piececnt[R_PAWN4];
//int R_pawncnt = bitCountPawnR(bitpiece); //bitCount16(bitpiece & 0x00000AA8);
    //int horse_cannon_cnt = bitCountMSB(bitpiece & 0x0ff00000);

// 2 pawns vs aaee - draw
if (((bitpiece & 0x55555000) == 0x00055000) && (B_pawncnt <= 2)
	 && ((bitpiece & 0xaaa00000) == 0) && (R_pawncnt <= 2)) 
{		score /= 8;
		goto eval_end;
}

if (((bitpiece & 0xaaaaa000) == 0x000aa000) && (R_pawncnt <= 2)
	 && ((bitpiece & 0x55500000) == 0) && (B_pawncnt <= 2)) 
{		score /= 8;
		goto eval_end;
}

  	//int bkingpos=boardsq[32];
  //int BkingFile = nFile(boardsq[32]);
  int BkingRank = nRank(boardsq[32]);
  //int wkingpos=boardsq[33];
  //int WkingFile = nFile(boardsq[33]);
  int WkingRank = nRank(boardsq[33]);
  	//Add some bonus when white king pins black ADVISOR, since the mobility of black ADVISOR is reduced,
// add more when white rook can check.

    int DstSq; //nDisp; //, k, n;
    SlideMoveStruct *lpsmv;
    SlideMaskStruct *lpsmsFileMask; //, *lpsmsRankMask;
    //lpsmsRankMask = PreGen.smsRankMaskTab[x ] + wBitRanks[y];
    //lpsmsFileMask = PreGen.smsFileMaskTab[BkingRank ] + wBitFiles[BkingFile];
    // 3. 判断是否将帅对脸
    //
    //sqDst = boardsq[33-side];
    //if (sqDst >= 0)
    //if (NOTSQEMPTY(boardsq[33-side]))
    //	{
    	//int	sqDst = boardsq[33-side];
    	//if (BkingFile == nFile(wkingpos) && (lpsmsFileMask->CannonCap & PreGen.wBitFileMask[wkingpos]) != 0)
    	if (BkingFile == WkingFile)
    	{
        lpsmsFileMask = PreGen.smsFileMaskTab[BkingRank ] + wBitFiles[BkingFile];
        if ((lpsmsFileMask->CannonCap & PreGen.wBitFileMask[boardsq[33]]) != 0)
        {
        lpsmv = PreGen.smvFileMoveTab[BkingRank ] + wBitFiles[BkingFile];
        //for (int n=2; n--;)
        // n=0 move down from Bking
        //{
        	//DstSq = lpsmv->CannonCap[0]; [n]; // + nDisp;
        	//if ((DstSq) !=0)
          //{

          	//DstSq +=BkingFile-1;
          	//if ((DstSq) == wkingpos)
            //{
        			DstSq = lpsmv->RookCap[0]; //[n]; // + nDisp;
          		//if ((DstSq) !=0)
          		//{

          			DstSq +=BkingFile; //-1;
          			if ((piece[DstSq]>>2)==ADVISOR)
          			{
          				score += (((piece[DstSq]&1)<<6) - 32) ;	// R_ADVISOR (color1)+=32,  B_ADVISOR (color0)-=32

          			}


                //}
      }
    	}
		//}

  	// if king on top rank with attacking pawns under, add bonus

  	if (WkingRank == 7)
  	for (int bb=pawn_index[0]; bb>=2; bb-=2)
    {
        if (NOTSQEMPTY(boardsq[bb]))
        {
  	        if (nRank(boardsq[bb]) > WkingRank)
  	        {	score -= 32;
  	        	break;
  	        }
  	    }
  	}

  	//int BkingRank = nRank(boardsq[32]);
  	if (BkingRank == 2)
  	for (int bb=pawn_index[1]; bb>=2; bb-=2)
    {
        if (NOTSQEMPTY(boardsq[bb]))
        {
  	        if (nRank(boardsq[bb]) < BkingRank)
  	        {	score += 32;
  	        	break;
  	        }
  	    }
  	}

//int B_cann_cnt = bitCountCannB(bitpiece);
//int R_cann_cnt = bitCountCannR(bitpiece);
//board pos
// 0  1  2  3  4  5  6  7  8
// 16 17 18 19 20 21 22 23 24
// 32 33 34 35 36 37 38 39 40
// 48 49 50 51 52 53 54 55 56
// 64 65 66 67 68 69 70 71 72
//
// 80 81 82 83 84 85 86 87 88
// 96 97 98 99 100 1 02 03 04
//112 13 14 15 116 7 18 19 20
//128 29 30 31 132 3 34 35 36
//144 45 46 47 148 9 50 51 52

//if ((m_side==0 && score>=0) || (m_side!=0 && score <0))

	//rook vs cannon+2 advisors
if ( ((B_rookcnt == 1 && (bitpiece & 0x05500554)==0 ) // no other B attack piece
&& (R_canncnt == 1 && (bitpiece & 0xA0A0A000)==0x0000A000) //2advisor
&& ((piece[132]&61)==R_ADVISOR1)
&& (((piece[115]&61)==R_CANNON1 && WkingFile==3) || ((piece[117]&61)==R_CANNON1 && WkingFile==5)) )
||
 ((R_rookcnt == 1 && (bitpiece & 0x0AA00AA8)==0 ) // no other R attack piece
&& (B_canncnt == 1 && (bitpiece & 0x50505000)==0x00005000) //2advisor
&& ((piece[20]&61)==B_ADVISOR1)
&& (((piece[35]&61)==B_CANNON1 && BkingFile==3) || ((piece[37]&61)==B_CANNON1 && BkingFile==5)) ) )
{
//#ifdef PRTBOARD
//print_board(score);
//#endif
	score /= 8;
//#ifdef PRTBOARD
//print_bonus(score);
//#endif
goto eval_end;
}

if ((B_pawncnt <= 1) && (R_pawncnt <= 1))
{ 
 if ((B_rookcnt <= 1) && (R_rookcnt <= 1))
 { 	
 	if ((B_canncnt <= 1) && (R_canncnt <= 1))
 	{ 		
 		if ((B_horscnt <= 1) && (R_horscnt <= 1))
 		{ 	
 	int mul_factor = eg_mul[B_pawncnt*2+R_pawncnt]
 	[B_rookcnt*2+R_rookcnt][B_canncnt*2+R_canncnt]
 	[B_horscnt*2+R_horscnt]
 	//[piececnt[B_ELEPHAN1]+piececnt[B_ADVISOR1]][piececnt[R_ELEPHAN1]+piececnt[R_ADVISOR1]];
 	[bitCountEleAdvB(bitpiece)][bitCountEleAdvR(bitpiece)];
 	score = (score * mul_factor) / 16;
 	goto eval_end;
 		}
	}
 }
}

eval_end: 
	  return score;
}	  
//1113 end of endgame knowledge


int rook_attack_advele = 0;
//int Board::EvalSide(int poscolor)
template<int poscolor>
int Board::EvalSide()
{
    int score=0;
    int bbp, DstSq, z, pieceDstSq, piecedestval; //j, fcannon,
    //unsigned char *DstPtr, *EyeLegPtr;
//	short *DstPtr2;
    int x, y, nDisp; //, k, n;
    SlideMoveStruct *lpsmv;
    int pieceDstSq1; //, xx; //, bbp; //, mob;

//		int rook_count, cann_count, hors_count, oppadvs_count, oppelep_count;
//		rook_count= bitCountMSB((bitpiece & (0x50000000<<poscolor)));
//    cann_count= bitCountMSB((bitpiece & (0x05000000<<poscolor)));
//    hors_count= bitCountMSB((bitpiece & (0x00500000<<poscolor)));
//    oppadvs_count= bitCount16((bitpiece & (0x0000A000>>poscolor))); //>>12);
//    oppelep_count= bitCountMSB((bitpiece &(0x000A0000>>poscolor)));

    //int opprook_count= bitCountMSB((bitpiece & (0xA0000000>>poscolor)));
    //RCH_count += (rook_count*2) + cann_count + hors_count;
    //1108 RCH_count += (piececnt[B_ROOK1+poscolor]*2) + piececnt[B_CANNON1+poscolor] + piececnt[B_HORSE1+poscolor];
/*
0,0,0,0,4,2,2,2,2,  0,0,0,0,0,0,0,
0,0,0,0,4,2,2,2,2,  0,0,0,0,0,0,0,
0,0,0,0,4,2,2,2,2,  0,0,0,0,0,0,0,
6,6,0,0,4,2,2,8,8,  0,0,0,0,0,0,0,
6,6,6,6,4,8,8,8,8,  0,0,0,0,0,0,0,

7,7,7,7,5,9,9,9,9,  0,0,0,0,0,0,0,
7,7,1,1,5,3,3,9,9,  0,0,0,0,0,0,0,
1,1,1,1,5,3,3,3,3,  0,0,0,0,0,0,0,
1,1,1,1,5,3,3,3,3,  0,0,0,0,0,0,0,
1,1,1,1,5,3,3,3,3};
*/
 int C_xriver_rook_count;     
 int L_xriver_rook_count;
 int L_near_hors_count;     
 int L_near_pawn_count;     
 int R_xriver_rook_count;     
 int R_near_hors_count;     
 int R_near_pawn_count;
#ifndef _WIN64
if (POPCNT_CPU)
#endif	
{	
 C_xriver_rook_count =
     PCbitCountMSB( (bitattk[5-poscolor] ) & (0x50000000<<poscolor));
 L_xriver_rook_count =
     PCbitCountMSB( (bitattk[1-poscolor] | bitattk[7-poscolor]) & (0x50000000<<poscolor));
 L_near_hors_count =
     PCbitCountMSB( (bitattk[1-poscolor] ) & (0x00500000<<poscolor));
 L_near_pawn_count =
     PCbitCount16( (bitattk[1-poscolor] ) & (0x00000554<<poscolor));
 R_xriver_rook_count =
     PCbitCountMSB( ( bitattk[3-poscolor] | bitattk[9-poscolor]) & (0x50000000<<poscolor));
 R_near_hors_count =
     PCbitCountMSB( ( bitattk[3-poscolor] ) & (0x00500000<<poscolor));
 R_near_pawn_count =
     PCbitCount16( ( bitattk[3-poscolor] ) & (0x00000554<<poscolor));
}
#ifndef _WIN64
else //POPCNT_CPU
{	
 C_xriver_rook_count =
     bitCountMSB( (bitattk[5-poscolor] ) & (0x50000000<<poscolor));
 L_xriver_rook_count =
     bitCountMSB( (bitattk[1-poscolor] | bitattk[7-poscolor]) & (0x50000000<<poscolor));
 L_near_hors_count =
     bitCountMSB( (bitattk[1-poscolor] ) & (0x00500000<<poscolor));
 L_near_pawn_count =
     bitCount16( (bitattk[1-poscolor] ) & (0x00000554<<poscolor));
 R_xriver_rook_count =
     bitCountMSB( ( bitattk[3-poscolor] | bitattk[9-poscolor]) & (0x50000000<<poscolor));
 R_near_hors_count =
     bitCountMSB( ( bitattk[3-poscolor] ) & (0x00500000<<poscolor));
 R_near_pawn_count =
     bitCount16( ( bitattk[3-poscolor] ) & (0x00000554<<poscolor));
}
#endif
    //for (poscolor=2; poscolor--;)
    {
            // Cannon
        //for (bbp=26+poscolor; bbp>=24; bbp-=2)
        for (bbp=cann_index[poscolor]; bbp>=24;  bbp-=2)
        {
            if (NOTSQEMPTY(boardsq[bbp]))
            {
               int pos = boardsq[bbp];
                y = nRank(pos); // / 16;
                x = nFile(pos); //pos - nDisp; //nFile(pos); // % 16;

                // cannon move left-right

                nDisp = (y<<4);  //(y<<3) + y; // * 9; //16;
                //nDisp[0] = x;
                lpsmv = PreGen.smvRankMoveTab[x ] + wBitRanks[y];
                //lpsmv[0] = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
								//int mob = lpsmv->NonCapCnt;
								int mob = lpsmv->NonCapCannonCnt[0] + lpsmv->NonCapCannonCnt[1];
                for (int k=2; k--;) {

                // cannon mobility score

                //score += CANNON_MOBSCORE[lpsmv->NonCapCnt][poscolor];
                for (int n=2; n--;)
                {
                		DstSq = lpsmv->RookCap[n]; // + nDisp;
                    //if ((DstSq) !=0)
                    if (DstSq != pos)
                    {DstSq +=nDisp; //-1;
                    		pieceDstSq1 = piece[DstSq];
                            //Cnt>0 means cannon and king separated by at least 1 empty squares
                        if ( (pieceDstSq1+poscolor==R_KING) && lpsmv->NonCapCannonCnt[n] >0)
                        {
                        	//if (rook_count >0)
                        	{
                                //if (x==4)
                                if (k==0)
                                {
                                			//score += EMPTY_CANN_SCORE[rook_count][lpsmv->NonCapCannonCnt[n]];
//中炮审局
//无抽将加很小的分数即可
//考虑 马兵
//有抽将要加比较大的分数
//if(车炮抽将)
//    if(the other rook is over river) value += 80;
//    if(hors is close to king) value += 80;
//    if(pawn is close to king enough value += 30;
//something like that.
//#ifdef PRTBOARD
//		print_board(score);
//#endif

//int threatscore =
score += EMPTY_CANN_SCORE[lpsmv->NonCapCannonCnt[n]]
 + (L_xriver_rook_count + R_xriver_rook_count) * 20 //1110 20 //1108 32
 + (L_near_hors_count + R_near_hors_count) *10 //1110 10        //1108 8
 + (L_near_pawn_count + R_near_pawn_count) *10 ; //1110 10;       //1108 4;
//if opprook=0, add bonus
//if (p_endgame)
//   threatscore += 16; //32;
//#ifdef PRTBOARD
//	print_bonus(score);
//#endif

//score += threatscore;
//if (threatscore >=96)
//	evalthreat[poscolor]=1;
                                }
                                else
                                {

                                	//ignore single bottom cannon //RCH in [1][3] or [0][2] >1
                                	if (bitCountMSB((bitattk[(n<<1)+1-poscolor] & (0x55500000 <<poscolor) )) >1)
                                	//ignore cann -- king -- cann
                                	//DstSq = lpsmv->CannonCap[n];
                                	//if ((DstSq==0) || ((piece[DstSq+nDisp]&61) - poscolor != B_CANNON1))
                                	{
                                		//score += BOTTOM_CANN_SCORE[x][poscolor] + oppadvs_count*8; //4; //8;
//底炮审局  //1108 bottom_cann eval
//#ifdef PRTBOARD
//		print_board(score);
//#endif
//int threatscore =
score += BOTTOM_CANN_SCORE[x] + piececnt[R_ADVISOR1-poscolor] *8 // 6 //1108 lmrparm2  //8
 + (x<4 ? L_xriver_rook_count : R_xriver_rook_count) * 17        //1108 lmrparm3 //16
 + (x<4 ? L_near_hors_count : R_near_hors_count) * 6             //1108 lmrparm2 //8
 + (x<4 ? L_near_pawn_count : R_near_pawn_count) * 4;            //1108 lmrparm1; //4;
//#ifdef PRTBOARD
//	print_bonus(score);
//#endif

//score += threatscore;
//if (threatscore >=96)
//	evalthreat[poscolor]=1;
}
/*
else
{

#ifdef PRTBOARD
if (prtboard<10)
{
	print_board();
	printf("score=%d, bot_cann_score=%d, oppadvs*8=%d\n", score, BOTTOM_CANN_SCORE[x][poscolor],oppadvs_count*8);
}
#endif

                                	}
*/
                                }
                           }
                          }
                    DstSq = lpsmv->CannonCap[n]; // + nDisp;
                    //if ((DstSq) !=0)
                    if (DstSq != pos)
                    {DstSq +=nDisp; //-1;
                     pieceDstSq = piece[DstSq];
                     if ((pieceDstSq&1)==poscolor)
                     {    score +=score1poscolor; //++; //+= SCORE1[poscolor]; //PROTPVAL[piece[y]];
                     }
                     else
                     {
                        score += ATTKPVAL[pieceDstSq];
                        bitpiece_attk |= (1 << (pieceDstSq&31)); 
                        //score+=score2poscolor;
                        z = lpsmv->SuperCap[n]; // + nDisp;
                        //if ((z) !=0)
                        if (z != pos)
                        {   z +=nDisp; //-1;
                        		int piecedestsuper = (piece[z] &61) + poscolor;
                            if (piecedestsuper == R_KING) // || piecedestsuper == R_ROOK1)
                            {
                            	  // cannon - rook -- xxx --- king
                              	if (((pieceDstSq1 &61) - poscolor ) == B_ROOK1)
                                {
//#ifdef PRTBOARD
//		print_board(score);
//#endif
                                            //score+=score64poscolor; //80; //mate_threat=1;
                                            //int threatscore=
                                            score += score64poscolor;
//中炮审局
if (k==0)
{
	//threatscore
	score
	 += (L_xriver_rook_count + R_xriver_rook_count) * 20  //1108 32
	 + (L_near_hors_count + R_near_hors_count) * 20       //1108 16
	 + (L_near_pawn_count + R_near_pawn_count) * 20;      //1108 8;
}
else //底炮审局   //1108 bottom_cann eval
{
	//threatscore
	score
	+= (x<4 ? L_xriver_rook_count : R_xriver_rook_count) * 34 //1108 lmrparm3 *2 //32
	+ (x<4 ? L_near_hors_count : R_near_hors_count) * 12      //1108 lmrparm2 *2      //16
	+ (x<4 ? L_near_pawn_count : R_near_pawn_count) * 8;      //1108 lmrparm1 *2;     //8;
}
//#ifdef PRTBOARD
//	print_bonus(score);
//#endif

//score += threatscore;
//if (threatscore >=96)
//	evalthreat[poscolor]=1;
                                }
                                // cannon - pinned opp rook -- xxx --- king
                                else if (((pieceDstSq1 &61) + poscolor ) == R_ROOK1)
                                {
                                            score+=score32poscolor;  //1108 bottom cann eval  score16poscolor;
                                }
                            	  else
                            	  {
                            	  // pinned  cannon -- xxx --- hors/rook --- king   ///rook
                            	  piecedestval = (pieceDstSq &61) + poscolor;
                            	  if (piecedestval == R_HORSE1 || piecedestval == R_ROOK1)
                            	  {

                            	  		score+=score64poscolor; //50; //SCORE50[poscolor]; //50
                            	  		//int threatscore=score64poscolor;
                                		if (DstSq==CENTRAL_POS[poscolor])  //132)  //central heart rook/hors //ADJ9_16(76) = 132
                                		{
//#ifdef PRTBOARD
//		print_board(score);
//#endif
                                    		//score+=(poscolor ? ((lpsmv->NonCapCannonCnt[n]<<3) - 100) : (100 - (lpsmv->NonCapCannonCnt[n]<<3)));    //65->125    //70; //mate_threat=1;
                                    		//threatscore +=
                                    		score += CENTRAL_HORSE_SCORE[lpsmv->NonCapCannonCnt[n]]
//中炮审局
	 + (L_xriver_rook_count + R_xriver_rook_count) * 20 //1108 32
	 + (L_near_hors_count + R_near_hors_count) * 20     //1108 16
   + (L_near_pawn_count + R_near_pawn_count) * 20;     //1108 8;

//#ifdef PRTBOARD
//	print_bonus(score);
//#endif
//score += threatscore;
//if (threatscore >=96)
//	evalthreat[poscolor]=1;
                                		}
                                }
                              	// only for supercap cannon and have xriver rook
                              	else if (L_xriver_rook_count+R_xriver_rook_count >0) //(rook_count >0)
                                {   //supercap king bonus
                                	  //score+=(poscolor ? lpsmv->NonCapCannonCnt[n] - 12 : 12 - lpsmv->NonCapCannonCnt[n]); //8 5; //cannon supercap king bonus
                              			if (k==0) //(x==4)
                              			{
                              					score += SUPERCAP_SCORE[lpsmv->NonCapCannonCnt[n]];
                              			    score += (rook_attack_advele *10 ); //1110 10);     //1108  16
                              		  }
                              			else score += SUPERCAP_BOTSCORE[lpsmv->NonCapCannonCnt[n]];
                              			//supercap pinned hors/cannon bonus
                              			pieceDstSq1 = (pieceDstSq1 &61) + poscolor;
                              			if (pieceDstSq1 == R_CANNON1 || pieceDstSq1 == R_HORSE1)
                                    			score+=score16poscolor; //*8; //score16poscolor;
                              			// central cannon - xxx - xxx - king and king door under attack
                                 		if (k==0 && (x==4) && piece[CENTRAL_POS[poscolor]]<=R_ADVISOR2 //ADJ9_16(76) = 132
                                                 && ((piece[ADVISOR_L[poscolor]]<=R_ADVISOR2  &&
                                                 // (IsAttackedBy(poscolor, ADVISOR_R[poscolor])    ) )
                                                 (IsAttackedBy<poscolor>(ADVISOR_R[poscolor])    ) )
                                                     || (piece[ADVISOR_R[poscolor]]<=R_ADVISOR2 &&
                                                     // (IsAttackedBy(poscolor, ADVISOR_L[poscolor])  ) )
                                                     (IsAttackedBy<poscolor>(ADVISOR_L[poscolor])  ) )
                                                    ))
                                    {
                                            score+=score64poscolor; //1112 score32poscolor  //16 //30; //30; //mate_threat=1;
// 如果车在底线保护帅(将)，则给予更大的罚分！
                                            for (int bbrook=29-poscolor; bbrook<=31; bbrook+=2)
                                            {
                                               	if (NOTSQEMPTY(boardsq[bbrook]))
            {
               int posrook = boardsq[bbrook];
                                                	if (nRank(posrook)== (1-poscolor)*9)				//==9   ==0
                                                {
                                                    if ((piece[ADVISOR_L[poscolor]]<=R_ADVISOR2 && posrook > ADVISOR_R[poscolor])		// 147   149
                                                            || (piece[ADVISOR_R[poscolor]]<=R_ADVISOR2 && posrook < ADVISOR_L[poscolor]))	// 149   147
                                                    {
                                                        score += score16poscolor*8; //1112 8;  //120;
                                                    }
                                                }
                                              }
                                            }
                                    }
                                } // end if rook_count
                              }
                        }	// end if R_KING

                        else if (piecedestsuper == R_ROOK1)
                        {
                            	  // pinned  cannon -- xxx --- hors/rook --- rook
                            	  piecedestval = (pieceDstSq &61) + poscolor;
                            	  if (piecedestval == R_HORSE1)
                            	  		score+=score32poscolor; //50; //SCORE50[poscolor]; //50
                                // cannon - rook -- xxx --- rook
                            	  else if (((pieceDstSq1 &61) - poscolor ) == B_ROOK1)
                                		score+=score32poscolor; //80; //mate_threat=1;
                                else if (piecedestval == R_ELEPHAN1)
                                		score+=score8poscolor;
                                else if ((pieceDstSq &1) == poscolor)
                                		score+=score8poscolor;

                        }	// end if R_ROOK1
                    }	// end if supercap z !=pos
                  }	// end if cannoncap oppside
                  }	// end if cannoncap DstSq !=pos
                }	// end if rookcap DstSq !=pos
              } // end for n

              if (k>0)
              {
								// cannon move up-down
                nDisp = x;
                lpsmv = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
                //mob += lpsmv->NonCapCnt;
                  mob += lpsmv->NonCapCannonCnt[0] + lpsmv->NonCapCannonCnt[1];
              }
              //mob += lpsmv[k]->NonCapCnt;
						}	// end for k
						score += CANNON_MOBSCORE[mob];
            }
				}	// end bbp

 		// 有双仕(士)但花心被帅(将)占领，要罚分，下同
    if (piece[CENTRAL_POS[poscolor]]>=B_KING && piececnt[R_ADVISOR1-poscolor]==2)
        score += score16poscolor;  //1112 score8

    //Have rook better than no rook
    //score += ROOK_BONUS[rook_count[0]][rook_count[1]];
//cann-hors vs cann-cann vs hors-horse bonus
/*
score += ROOK_CANN_HORS_BONUS[rook_count][cann_count][hors_count]
     + CANN_ELEP_BONUS[cann_count][oppelep_count]
    //score += HORS_ADVS_BONUS[hors_count][oppadvs_count];
     + CANN_ELEP_BONUS[hors_count][oppadvs_count];
*/
score += ROOK_CANN_HORS_BONUS[piececnt[B_ROOK1+poscolor]][piececnt[B_CANNON1+poscolor]][piececnt[B_HORSE1+poscolor]]
     + CANN_ELEP_BONUS[piececnt[B_CANNON1+poscolor]][piececnt[R_ELEPHAN1-poscolor]]
    //score += HORS_ADVS_BONUS[hors_count][oppadvs_count];
     + CANN_ELEP_BONUS[piececnt[B_HORSE1+poscolor]][piececnt[R_ADVISOR1-poscolor]];

    // 缺仕(士)怕双车，有20分罚分
    // 在罚分的情况下，如果有车对仕(士)相(象)有威胁，则每个车再加20分罚分
    //int threatscore = ROOK_ADVISOR_BONUS[attk_rook_count][oppadvs_count];
    int threatscore = ROOK_ADVISOR_BONUS[C_xriver_rook_count+L_xriver_rook_count+R_xriver_rook_count][piececnt[R_ADVISOR1-poscolor]];
#ifndef _WIN64
if (POPCNT_CPU)
#endif	
{
    if (threatscore != 0)
    {
    	if (piececnt[R_ELEPHAN1-poscolor] !=2)
    	//if ((bitpiece & (0x000A0000>>poscolor)) != (0x000A0000>>poscolor))
    		threatscore += score64poscolor;

    	else
    		//threatscore += (rook_attack_advele * rook_count * 16); //32);
    		threatscore += (rook_attack_advele * piececnt[B_ROOK1+poscolor] * score16poscolor); //160); //32);  //1108 *16-->*160

    	score += threatscore //;
    	//if rook not cross-river deduct score
    	 - (2-(L_xriver_rook_count + R_xriver_rook_count)) * 34 //1108 lmrparm3 *2  //1108 32
	 + (L_near_hors_count + R_near_hors_count) * 12             //1108 lmrparm2 *2  //1108 16
	 + (L_near_pawn_count + R_near_pawn_count) * 8;             //1108 lmrparm1 *2; //1108  8;

//0,0,0,0,4,2,2,2,2,  0,0,0,0,0,0,0,
//0,0,0,0,4,2,2,2,2,  0,0,0,0,0,0,0,
//0,0,0,0,4,2,2,2,2,  0,0,0,0,0,0,0,
//6,0,0,0,4,2,2,2,8,  0,0,0,0,0,0,0,
//6,6,6,6,4,8,8,8,8,  0,0,0,0,0,0,0,

//7,7,7,7,5,9,9,9,9,  0,0,0,0,0,0,0,
//7,1,1,1,5,3,3,3,9,  0,0,0,0,0,0,0,
//1,1,1,1,5,3,3,3,3,  0,0,0,0,0,0,0,
//1,1,1,1,5,3,3,3,3,  0,0,0,0,0,0,0,
//1,1,1,1,5,3,3,3,3};

	
    	//如果对方有车防守 -70

    	if (poscolor==0)
			score -= PCbitCountRookR(bitattk[1] | bitattk[3] | bitattk[5]) * 17; //lmrparm3;  //1108 16; //32;
			else
			score -= PCbitCountRookB(bitattk[0] | bitattk[2] | bitattk[4]) * 17; //lmrparm3;  //1108 16; //32;

//    	if (threatscore >=96)
//    		evalthreat[poscolor]=1;
    }


//y*(2-x)*4
//0 0 0
//8 4 0
//16 8 0
//    score += (hors_count * (2- oppadvs_count)) <<2;
//    score += (cann_count * (2- bitCountMSB(bitpiece &(0x000A0000>>poscolor)) )) <<2;

//add bonus if xriver_rook + 2cannon on same side, all cannon below FOURTHRANK
//L_near_cann_count = 2
//static const int FOURTHRANK[2] = {6, 3};
if ( ( (bitattk[1-poscolor] ) & (0x05000000<<poscolor)) == (0x05000000<<poscolor) )
if (nFile(boardsq[B_CANNON1 + poscolor]) != nFile(boardsq[B_CANNON2 + poscolor]))
if (nRank(boardsq[B_CANNON1 + poscolor]) != 6 - (poscolor*3) //FOURTHRANK[poscolor]
 && nRank(boardsq[B_CANNON2 + poscolor]) != 6 - (poscolor*3) //FOURTHRANK[poscolor]
 )
{
	//score += (L_xriver_rook_count * 128) + (R_xriver_rook_count * 64)
	score += (((L_xriver_rook_count + R_xriver_rook_count + 1) >>1) * 64)
	+ (L_near_pawn_count * 16);
	//如果对方有车马防守
    	score -= bitCountMSB(bitattk[1-poscolor] & (0xA0000000>>poscolor)) *10 //1110 10  //1108 16
    	       + bitCountMSB(bitattk[1-poscolor] & (0x0AA00000>>poscolor)) *10 ; //1110 10; //1108 8;
    	// 	score -= bitCountMSB(bitattk[1-poscolor] & (0xA0A00000>>poscolor)) * 16;
    	// 	score -= bitCountMSB(bitattk[1-poscolor] & (0xA0000000>>poscolor)) * 16;
}

// R_near_cann_count = 2
if ( ( (bitattk[3-poscolor] ) & (0x05000000<<poscolor)) == (0x05000000<<poscolor) )
if (nFile(boardsq[B_CANNON1 + poscolor]) != nFile(boardsq[B_CANNON2 + poscolor]))
if (nRank(boardsq[B_CANNON1 + poscolor]) != 6 - (poscolor*3) //FOURTHRANK[poscolor]
 && nRank(boardsq[B_CANNON2 + poscolor]) != 6 - (poscolor*3) //FOURTHRANK[poscolor]
 )
{
	//score += (R_xriver_rook_count * 128) + (L_xriver_rook_count * 64)
	score += (((L_xriver_rook_count + R_xriver_rook_count + 1) >>1) * score64poscolor)  //1108 64)
	+ (R_near_pawn_count * 16);
	//如果对方有车马防守
    	score -= PCbitCountMSB(bitattk[3-poscolor] & (0xA0000000>>poscolor)) *10 //1110 10 //1108 16
    	       + PCbitCountMSB(bitattk[3-poscolor] & (0x0AA00000>>poscolor)) *10 ; //1110 10; //1108 8;
    	//  score -= bitCountMSB(bitattk[3-poscolor] & (0xA0A00000>>poscolor)) * 16;
    	//  score -= bitCountMSB(bitattk[3-poscolor] & (0xA0000000>>poscolor)) * 16;
}



//preeval to fix endhorback
      //if oppking is on one side, and has rook, give bonus to cross-river horse and pawn
  //int bkingpos=boardsq[32];
  int BkingFile = nFile(boardsq[32]);
  int BkingRank = nRank(boardsq[32]);
  //int wkingpos=boardsq[33];
  int WkingFile = nFile(boardsq[33]);
  int WkingRank = nRank(boardsq[33]);
 if (poscolor==0)
 {
	if (WkingFile != 4)
	{
		int kingfile = WkingFile - 3; // 0 or 2
		int sideHorsCnt = PCbitCountHorsB(bitattk[1+kingfile]); // | bitattk[7+kingfile]);
		if (sideHorsCnt == 2)
			score += 18;
		if (PCbitCountRookB(bitattk[1+kingfile] | bitattk[7+kingfile]) > 0)
		{
			if (sideHorsCnt > 0)
			{
//#ifdef PRTBOARD
//		print_board(score);
//#endif
				//score += 92;
				int threatscore = 92;
		//侧面虎加300    2 or 6    2=3-1   6=5+1   0-1=-1   2-1=+1
			if (WkingRank==7 && (piece[6*16 + WkingFile+ (kingfile-1) ] &61)==B_HORSE1)	// hors file==2 or 6
				threatscore += 50 //46;
		//如果对方有车防守 -70 马 -40， 炮 - 30 主要是车马怕被压制，所以要扣分
			 - PCbitCountRookR(bitattk[1+kingfile] | bitattk[7+kingfile] | bitattk[5]) * 32
			 - PCbitCountCanHorR(bitattk[1+kingfile] | bitattk[5]) * 16;

//#ifdef PRTBOARD
//	print_bonus(score);
//#endif
 				//if (threatscore >= 96)
 				//	evalthreat[0]=1;
 				score += threatscore;
			}
			//if (bitCount16((bitattk[1+kingfile]) & 0x00000554) > 0)
			// 	score +=8; //32; //46;
			score += PCbitCount16((bitattk[1+kingfile]) & 0x00000554) * 32; //8;
	  }
	}
}
else
{
	if (BkingFile != 4)
	{
		int kingfile = BkingFile - 3; // 0 or 2
		int sideHorsCnt = PCbitCountHorsR(bitattk[kingfile]); // | bitattk[6+kingfile]);
		if (sideHorsCnt == 2)
			score += 18;
		if (PCbitCountRookR(bitattk[kingfile] | bitattk[6+kingfile]) > 0)
		{
			if (sideHorsCnt > 0)
			{
//#ifdef PRTBOARD
//		print_board(score);
//#endif
				//score -= 92;
				int threatscore = 92;
		//侧面虎加300    2 or 6    2=3-1   6=5+1   0-1=-1   2-1=+1
			if (BkingRank==2 && (piece[3*16 + BkingFile+ (kingfile-1) ] &61)==R_HORSE1)	// hors file==2 or 6
				threatscore += 50 //46;
		//如果对方有车防守 -70 马 -40， 炮 - 30 主要是车马怕被压制，所以要扣分
		   - PCbitCountRookB(bitattk[kingfile] | bitattk[6+kingfile] | bitattk[4]) * 32
			 - PCbitCountCanHorB(bitattk[kingfile] | bitattk[4]) * 16;

//#ifdef PRTBOARD
//	print_bonus(score);
//#endif
				//if (threatscore <= -96)
 				//	evalthreat[1]=1;
 				score += threatscore;
			}
			score += PCbitCount16((bitattk[kingfile]) & 0x00000AA8) * 32; //8;
		}
	}
}
}
#ifndef _WIN64
else //if POPCNT_CPU

{
    if (threatscore != 0)
    {
    	if (piececnt[R_ELEPHAN1-poscolor] !=2)
    	//if ((bitpiece & (0x000A0000>>poscolor)) != (0x000A0000>>poscolor))
    		threatscore += score64poscolor;

    	else
    		//threatscore += (rook_attack_advele * rook_count * 16); //32);
    		threatscore += (rook_attack_advele * piececnt[B_ROOK1+poscolor] * 16); //32);

    	score += threatscore //;
    	//if rook not cross-river deduct score
    	 - (2-(L_xriver_rook_count + R_xriver_rook_count)) * 32
	 + (L_near_hors_count + R_near_hors_count) * 16
	 + (L_near_pawn_count + R_near_pawn_count) * 8;
/*
0,0,0,0,4,2,2,2,2,  0,0,0,0,0,0,0,
0,0,0,0,4,2,2,2,2,  0,0,0,0,0,0,0,
0,0,0,0,4,2,2,2,2,  0,0,0,0,0,0,0,
6,0,0,0,4,2,2,2,8,  0,0,0,0,0,0,0,
6,6,6,6,4,8,8,8,8,  0,0,0,0,0,0,0,

7,7,7,7,5,9,9,9,9,  0,0,0,0,0,0,0,
7,1,1,1,5,3,3,3,9,  0,0,0,0,0,0,0,
1,1,1,1,5,3,3,3,3,  0,0,0,0,0,0,0,
1,1,1,1,5,3,3,3,3,  0,0,0,0,0,0,0,
1,1,1,1,5,3,3,3,3};
*/
	
    	//如果对方有车防守 -70

    	if (poscolor==0)
			score -= bitCountRookR(bitattk[1] | bitattk[3] | bitattk[5]) * 16; //32;
			else
			score -= bitCountRookB(bitattk[0] | bitattk[2] | bitattk[4]) * 16; //32;

//    	if (threatscore >=96)
//    		evalthreat[poscolor]=1;
    }


//y*(2-x)*4
//0 0 0
//8 4 0
//16 8 0
//    score += (hors_count * (2- oppadvs_count)) <<2;
//    score += (cann_count * (2- bitCountMSB(bitpiece &(0x000A0000>>poscolor)) )) <<2;

//add bonus if xriver_rook + 2cannon on same side, all cannon below FOURTHRANK
//L_near_cann_count = 2
//static const int FOURTHRANK[2] = {6, 3};
if ( ( (bitattk[1-poscolor] ) & (0x05000000<<poscolor)) == (0x05000000<<poscolor) )
if (nFile(boardsq[B_CANNON1 + poscolor]) != nFile(boardsq[B_CANNON2 + poscolor]))
if (nRank(boardsq[B_CANNON1 + poscolor]) != 6 - (poscolor*3) //FOURTHRANK[poscolor]
 && nRank(boardsq[B_CANNON2 + poscolor]) != 6 - (poscolor*3) //FOURTHRANK[poscolor]
 )
{
	//score += (L_xriver_rook_count * 128) + (R_xriver_rook_count * 64)
	score += (((L_xriver_rook_count + R_xriver_rook_count + 1) >>1) * 64)
	+ (L_near_pawn_count * 16);
	//如果对方有车马防守
    	score -= bitCountMSB(bitattk[1-poscolor] & (0xA0000000>>poscolor)) * 16
    	       + bitCountMSB(bitattk[1-poscolor] & (0x0AA00000>>poscolor)) * 8;
    	// 	score -= bitCountMSB(bitattk[1-poscolor] & (0xA0A00000>>poscolor)) * 16;
    	// 	score -= bitCountMSB(bitattk[1-poscolor] & (0xA0000000>>poscolor)) * 16;
}

// R_near_cann_count = 2
if ( ( (bitattk[3-poscolor] ) & (0x05000000<<poscolor)) == (0x05000000<<poscolor) )
if (nFile(boardsq[B_CANNON1 + poscolor]) != nFile(boardsq[B_CANNON2 + poscolor]))
if (nRank(boardsq[B_CANNON1 + poscolor]) != 6 - (poscolor*3) //FOURTHRANK[poscolor]
 && nRank(boardsq[B_CANNON2 + poscolor]) != 6 - (poscolor*3) //FOURTHRANK[poscolor]
 )
{
	//score += (R_xriver_rook_count * 128) + (L_xriver_rook_count * 64)
	score += (((L_xriver_rook_count + R_xriver_rook_count + 1) >>1) * 64)
	+ (R_near_pawn_count * 16);
	//如果对方有车马防守
    	score -= bitCountMSB(bitattk[3-poscolor] & (0xA0000000>>poscolor)) * 16
    	       + bitCountMSB(bitattk[3-poscolor] & (0x0AA00000>>poscolor)) * 8;
    	//  score -= bitCountMSB(bitattk[3-poscolor] & (0xA0A00000>>poscolor)) * 16;
    	//  score -= bitCountMSB(bitattk[3-poscolor] & (0xA0000000>>poscolor)) * 16;
}



//preeval to fix endhorback
      //if oppking is on one side, and has rook, give bonus to cross-river horse and pawn
  //int bkingpos=boardsq[32];
  int BkingFile = nFile(boardsq[32]);
  int BkingRank = nRank(boardsq[32]);
  //int wkingpos=boardsq[33];
  int WkingFile = nFile(boardsq[33]);
  int WkingRank = nRank(boardsq[33]);
 if (poscolor==0)
 {
	if (WkingFile != 4)
	{
		int kingfile = WkingFile - 3; // 0 or 2
		int sideHorsCnt = bitCountHorsB(bitattk[1+kingfile]); // | bitattk[7+kingfile]);
		if (sideHorsCnt == 2)
			score += 18;
		if (bitCountRookB(bitattk[1+kingfile] | bitattk[7+kingfile]) > 0)
		{
			if (sideHorsCnt > 0)
			{
//#ifdef PRTBOARD
//		print_board(score);
//#endif
				//score += 92;
				int threatscore = 92;
		//侧面虎加300    2 or 6    2=3-1   6=5+1   0-1=-1   2-1=+1
			if (WkingRank==7 && (piece[6*16 + WkingFile+ (kingfile-1) ] &61)==B_HORSE1)	// hors file==2 or 6
				threatscore += 50 //46;
		//如果对方有车防守 -70 马 -40， 炮 - 30 主要是车马怕被压制，所以要扣分
			 - bitCountRookR(bitattk[1+kingfile] | bitattk[7+kingfile] | bitattk[5]) * 32
			 - bitCountCanHorR(bitattk[1+kingfile] | bitattk[5]) * 16;

//#ifdef PRTBOARD
//	print_bonus(score);
//#endif
 				//if (threatscore >= 96)
 				//	evalthreat[0]=1;
 				score += threatscore;
			}
			//if (bitCount16((bitattk[1+kingfile]) & 0x00000554) > 0)
			// 	score +=8; //32; //46;
			score += bitCount16((bitattk[1+kingfile]) & 0x00000554) * 32; //8;
	  }
	}
}
else
{
	if (BkingFile != 4)
	{
		int kingfile = BkingFile - 3; // 0 or 2
		int sideHorsCnt = bitCountHorsR(bitattk[kingfile]); // | bitattk[6+kingfile]);
		if (sideHorsCnt == 2)
			score += 18;
		if (bitCountRookR(bitattk[kingfile] | bitattk[6+kingfile]) > 0)
		{
			if (sideHorsCnt > 0)
			{
//#ifdef PRTBOARD
//		print_board(score);
//#endif
				//score -= 92;
				int threatscore = 92;
		//侧面虎加300    2 or 6    2=3-1   6=5+1   0-1=-1   2-1=+1
			if (BkingRank==2 && (piece[3*16 + BkingFile+ (kingfile-1) ] &61)==R_HORSE1)	// hors file==2 or 6
				threatscore += 50 //46;
		//如果对方有车防守 -70 马 -40， 炮 - 30 主要是车马怕被压制，所以要扣分
		   - bitCountRookB(bitattk[kingfile] | bitattk[6+kingfile] | bitattk[4]) * 32
			 - bitCountCanHorB(bitattk[kingfile] | bitattk[4]) * 16;

//#ifdef PRTBOARD
//	print_bonus(score);
//#endif
				//if (threatscore <= -96)
 				//	evalthreat[1]=1;
 				score += threatscore;
			}
			score += bitCount16((bitattk[kingfile]) & 0x00000AA8) * 32; //8;
		}
	}
}
}
#endif

 } // end for poscolor

    return score;

}

template<int poscolor>
int Board::EvalHorsPawn()
{
    int score=0;
    int bbp, DstSq, x, y, z, pieceDstSq;
    int nDisp, piecedestval; //, k, n;
    SlideMoveStruct *lpsmv;
    unsigned char *DstPtr, *EyeLegPtr;
//Eval Rook
        //for (bbp=30+poscolor; bbp>=28; bbp-=2)
        for (bbp=rook_index[poscolor];  bbp>=28; bbp-=2)
        {
            if (NOTSQEMPTY(boardsq[bbp]))
            {
               int pos = boardsq[bbp];
               //if (oppadvs_count==0 && rook_count==2 && pos==CENTRAL_POS[poscolor])
               //		score += score64poscolor;

                y = nRank(pos); // / 16;
                x = nFile(pos); //pos - nDisp; //nFile(pos); // % 16;
                //if (OPPHALF(pos, poscolor) || (x==4) )
                //	attk_rook_count++;
                // move left-right
                nDisp = (y<<4);  //(y<<3) + y; // * 9; //16;
                //nDisp[0] = x;
                lpsmv = PreGen.smvRankMoveTab[x ] + wBitRanks[y];
                //lpsmv[0] = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
                //int mob = lpsmv->NonCapCnt;
                int mob = lpsmv->NonCapCannonCnt[0] + lpsmv->NonCapCannonCnt[1];
                for (int k=2; k--;)
                {
                for (int n=2; n--;)
                {
                    DstSq = lpsmv->RookCap[n]; // + nDisp;
                    //if ((DstSq) !=0)
                    if (DstSq != pos)
                    {DstSq +=nDisp; //-1;
                        pieceDstSq = piece[DstSq];
                        if ((pieceDstSq&1)==poscolor)
                        {
                            score += score1poscolor; //score1[poscolor]; //++;
                            piecedestval = (pieceDstSq &61) - poscolor;
      			if (piecedestval==B_ROOK1)
      			{	score += score2poscolor; //double rook bonus
//      				double_B_rook = true;
      			}
                            // discover bonus rook -- hors/cannon -- king
                            if (piecedestval==B_CANNON1 || piecedestval==B_HORSE1)
                            {
                                z = lpsmv->CannonCap[n]; // + nDisp;
                                //if ((z) !=0)
                                if (z != pos)
                                {z +=nDisp; //-1;
                                    if (piece[z] +poscolor==R_KING)

                                    {
                                        score+=score32poscolor; //30; //mate_threat=1;
                                    } // SCORE30[poscolor]; // 10;
                                }
                            }
                        }
                        else
                        {
                            score += ATTKPVAL[pieceDstSq];
                            //bitpiece_attk |= (1 << (pieceDstSq&31)); //attk by rook not counted
                            //score+=score2poscolor;
                            piecedestval = (pieceDstSq &61) + poscolor;

                            // pinned bonus  rook -- cannon/hors --- rook
                            if (piecedestval==R_CANNON1 || piecedestval==R_HORSE1)
                            {
                                z = lpsmv->CannonCap[n]; // + nDisp;
                                //if ((z) !=0)
                                if (z != pos)
                                {z +=nDisp; //-1;
                                    if ( ((piece[z] &61)+poscolor==R_ROOK1)
                                            //&& IsAttackedBy(oppside(poscolor), z)==0)  //z is not protected
                                        && IsAttackedBy<oppside(poscolor)>(z)==0)
                                        score+=score32poscolor; //30; //SCORE30[poscolor]; // 10;

                                    // central cannon/hors pinned by rook
                                    else if ( ((piece[z] &61)==R_KING)  //ADJ9_16(76) = 132
                                            )
                                    {
                                        if (DstSq==CENTRAL_POS[poscolor])
                                        {score+=score32poscolor*3; //]*3; //100; //mate_threat=1;
                                        	//evalthreat[poscolor]=1;
                                      }
                                        else //rook pin -- cannon/hors -- king
                                        score+=score16poscolor;
                                    }

                                }
                            }
                            else if (piecedestval == R_ADVISOR1 || piecedestval == R_ELEPHAN1)
                            {
                            	rook_attack_advele=1;
                            	if (p_endgame==1 && k==0) //rook move up-down
                            	{
                            		int kingDstSq = lpsmv->RookCap[oppside(n)]; // + nDisp;
                                //if ((kingDstSq) !=0)
                                if (kingDstSq != pos)
                                {
                                	kingDstSq +=nDisp; //-1;
                                	// rook followed by open king
                                  if ((piece[kingDstSq] - poscolor) == B_KING)
                        	           score += score8poscolor;
                                }
                              }
                            }
                        }
                    }
                } // end for n

								// rook move up-down
                if (k>0)
                {
            				nDisp = x;
            				lpsmv = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
            				//mob += lpsmv->NonCapCnt;
            				  mob += lpsmv->NonCapCannonCnt[0] + lpsmv->NonCapCannonCnt[1];
          			}
          			//mob += lpsmv[k]->NonCapCnt;
              } // end for k
               score += ROOK_MOBSCORE[mob];

            } // end if >=0
					} // end bbp


	           //case HORSE:
        //for (bbp=22+poscolor; bbp>=20; bbp-=2)
        for (bbp=hors_index[poscolor];  bbp>=20; bbp-=2)
        {
            if (NOTSQEMPTY(boardsq[bbp]))
            {
               int pos = boardsq[bbp];
                int nMob = 0;  // hors mobility
                DstPtr = g_KnightMoves[pos];
                EyeLegPtr = g_HorseLegs[pos];
                DstSq = *DstPtr;
                while (DstSq !=0) //>=0) //!=255) // >= 0)  //!= 0  ????
                {
                    //EyeLeg = *EyeLegPtr;
                    if (piece[*EyeLegPtr] == 0)
                    {		DstSq--;
                        pieceDstSq = piece[DstSq];
                        if (pieceDstSq==0)
                        {
                            //score+=3; //3; //hors mobility
                            //if dstsq not attacked by oppside
                            if ( HOMEHALF(DstSq, poscolor) ||
                            	// (IsAttackedBy(oppside(poscolor), DstSq) == 0))
                            	(IsAttackedBy<oppside(poscolor)>(DstSq) == 0))
                                nMob++;
                        }
                        else if ((pieceDstSq&1) == poscolor) // same color  - protect score
                        {
                            score+= 1; //score1poscolor; // += SCORE1[poscolor];
                            //score+=KNIGPROTPVAL[pieceDstSq];
                            if ((pieceDstSq &61) - poscolor == B_HORSE1)
                            	score += 3; // double hors bonus
                        }
                        else
                        {
                            if (pieceDstSq >= B_HORSE1 || HOMEHALF(DstSq, poscolor) ||
                            	 // (IsAttackedBy(oppside(poscolor), DstSq) == 0))
                            	 (IsAttackedBy<oppside(poscolor)>(DstSq) == 0))
                                nMob++;
                            score+=ATTKPVAL_3[pieceDstSq];     // ATTKPVAL_3[pieceDstSq] ;
                            bitpiece_attk |= (1 << (pieceDstSq&31));
                            //score+=score2poscolor;
                        }
                    }
                    DstPtr ++;
                    DstSq = *DstPtr;
                    EyeLegPtr ++;
                }

                score += HORSE_MOBSCORE[nMob];
                //  score += nMob/8;
                // side horse pressed by rook
                int nDisp=c_SideKnight[pos];
                if (nDisp !=0 && ((piece[pos + nDisp] &61) + poscolor == R_ROOK1)) //+poscolor == R_ROOK1))
                {	//if (IsAttackedBy(poscolor, pos))	//protected horse
                    //z = IsAttackedBy(poscolor, pos);
                    z = IsAttackedBy<poscolor>(pos);
                    if (z>3)	//protected horse by elep/bis/pawn
                        score-= 64; //1111 8*8; //score8poscolor; //8-(poscolor<<4);  // 8 //10;
                    else if (z>0)	//protected by rook/can/hors
                        score-= 128; //1111 16*8; //score16poscolor; //16-(poscolor<<5); //16  //25; //SCORE10[poscolor];  //50
                    else
                        score-= 256;  //11132*8; //score32poscolor; //32-(poscolor<<6); //32 //50; //SCORE50[poscolor];
                }


            }
				} // end bbp

        //case ELEPHAN:
        for (bbp=elep_index[poscolor];  bbp>=16; bbp-=2)
        {
            if (NOTSQEMPTY(boardsq[bbp]))
            {
               int pos = boardsq[bbp];
               //DstPtr = g_advelemoves[pos];
                DstPtr = g_KnightMoves[pos] + 9;

            DstSq = *DstPtr;
            while (DstSq != 0)
            {
                pieceDstSq = piece[DstSq];
                if (pieceDstSq && piece[(pos+DstSq) >>1]==0)
                {
                	if ( ((pieceDstSq&1) !=poscolor)   )  // color not same side
                	{
                			score += 20; //32;
                			bitpiece_attk |= (1 << (pieceDstSq));
                  }
                	else if ((pieceDstSq &61) - poscolor == B_ELEPHAN1)
                      score += 2; // double elephant bonus
                }
                DstPtr ++;
                DstSq = *DstPtr;
            }
        }
} // end bbp

        //case ADVISOR:
        for (bbp=advs_index[poscolor];  bbp>=12; bbp-=2)
        {
            if (NOTSQEMPTY(boardsq[bbp]))
            {
               int pos = boardsq[bbp];
               //DstPtr = g_advelemoves[pos];
                DstPtr = g_KnightMoves[pos] + 9;

            DstSq = *DstPtr;
            while (DstSq != 0)
            {
                pieceDstSq = piece[DstSq];
                if (pieceDstSq )
                {
                	if ( ((pieceDstSq&1) !=poscolor)   )  // color not same side
                	{
                			score += score16poscolor;  //1112 20; //32;
                			bitpiece_attk |= (1 << (pieceDstSq));
                  }
                	else //if ((pieceDstSq &61) - poscolor == B_ADVISOR1)
                      score+= score8poscolor; //1112 ++; // += 1; // double advisor bonus
                }
                DstPtr ++;
                DstSq = *DstPtr;
            }
        }
} // end bbp

        //case PAWN:

        //for (bbp=10+poscolor; bbp>pawn_index[poscolor]; bbp-=2)
        for (bbp=pawn_index[poscolor]; bbp>=2; bbp-=2)
        {
            //pos = boardsq[bbp];
            //if (pos >=0 )
            //	if (NOTSQEMPTY(pos))
            //{
            	if (NOTSQEMPTY(boardsq[bbp]))
            {
               int pos = boardsq[bbp];
                DstPtr = g_PawnMoves[pos][poscolor];
                DstSq = *DstPtr;
                while (DstSq !=0) //!=255) // >= 0)
                {	DstSq--;
                    pieceDstSq = piece[DstSq];
                    if (pieceDstSq==0)
                    {
                        //mobscore++
                    }
                    else if ((pieceDstSq&1) == poscolor)  // same color  - protect score
                    {
                        //if (pieceDstSq<=R_PAWN5 && nFile(DstSq) >=3 && nFile(DstSq) <=5)
                        //	score += 20;
                        if (pieceDstSq<=R_PAWN5)
                            score += PAWN_DOUBLE_BONUS[nFile(DstSq)]; //[p_endgame];
                        else
                            score += 1; //score1poscolor; //++; //+= SCORE1[poscolor];

                    }

//river pawn capture bonus

                    else if (pieceDstSq<=R_PAWN5 &&	nRank(DstSq)==4+poscolor) //== 4) == 5) [0] [1]
                    {
                        score += 80; //score16poscolor*5; //*5; //*2 + score32poscolor/2; //80;
                    }

                    else
                    {
                        score += ATTKPVAL_3[pieceDstSq];  //ATTKPVAL_3[pieceDstSq];
                        bitpiece_attk |= (1 << (pieceDstSq&31));
                    }

                    DstPtr ++;
                    DstSq = *DstPtr;
                }

            }
        } // end for bbp

return score;

}

//king safety
template<int poscolor>
int Board::EvalKingSafety()
{
    unsigned char *DstPtr;
    int score=0;

        //int oppkingpos = boardsq[33];
        DstPtr = g_PawnMoves[boardsq[33-poscolor]][1-poscolor] +3;
        int DstSq = *DstPtr;
        while (DstSq !=0)
        {
            //int pieceDstSq = piece[DstSq];
            //if ((pieceDstSq==0) || (pieceDstSq&1) == 0)  //!= oppside(poscolor))  // color not same side
            {

              //kingattkpt += Countkingattkpt<0>(DstSq, oppkingpos); // * 32;
             score += Countkingattkpt<poscolor>(DstSq, boardsq[33-poscolor]);
            }
            DstPtr --; //++;
            DstSq = *DstPtr;
        }
        return score;
        //score += (8<<kingattkpt)-8; // 0, 8, 24, 56, 120
}

//gives_check() tests whether a pseudo-legal move gives a check
bool Board::gives_check(int from, int dest)
{
	bool givesCheck; // = false;
	//make move and test whether opp king is under attacked
	HistRecord *hisptr;
    hisptr = m_hisrecord + m_hisindex;
    int piecefrom=piece[from];
    int piecedest=piece[dest];
    
    wBitRanks[nRank(from)] ^= PreGen.wBitRankMask[from];  // / 9
    wBitFiles[nFile(from)] ^= PreGen.wBitFileMask[from];  // % 9
// 2. 如果没有被吃的棋子，那么更新目标格的位行和位列。
    //    换句话说，有被吃的棋子，目标格的位行和位列就不必更新了。
    if (piecedest==EMPTY)
    {
        wBitRanks[nRank(dest) ] ^= PreGen.wBitRankMask[dest];
        wBitFiles[nFile(dest) ] ^= PreGen.wBitFileMask[dest];
    }
    else
    {
        boardsq[piecedest]=SQ_EMPTY;
    }
    
		boardsq[piecefrom] = dest;
    piece[dest]=piecefrom;
    piece[from]=EMPTY;
    
    //no chkreq for psuedo move

    chgside(m_side);
    hisptr->htab.table.move = (from<<8)+dest;
    hisptr->htab.capture = piecedest;
    m_hisindex++;
//---- test whether opp king is under attacked
   givesCheck =  (IsInCheck<1>(m_side)); //singlechk
   //if (IsInCheck<1>(m_side)) //singlechk
   //{
   //	 givesCheck = true;
   //}	

//--- unmakemove
//HistRecord *hisptr;
    m_hisindex--;
    hisptr = m_hisrecord + m_hisindex;

    dest=hisptr->htab.dest;
    from=hisptr->htab.from;
    piecefrom=piece[dest];
    piecedest=hisptr->htab.capture;


    piece[from]=piecefrom;
    piece[dest]=piecedest;
		chgside(m_side);

    if (piecedest)
    {
        boardsq[piecedest] = dest;
    }
    else
    {
        wBitRanks[nRank(dest)] ^= PreGen.wBitRankMask[dest];
        wBitFiles[nFile(dest)] ^= PreGen.wBitFileMask[dest];
    }
		boardsq[piecefrom] = from;
    wBitRanks[nRank(from)] ^= PreGen.wBitRankMask[from];
    wBitFiles[nFile(from)] ^= PreGen.wBitFileMask[from];
    
 return givesCheck;   
}



// Generate non-capturing checks used in Quiesce search, only gen for rook, cannon and hors to simplify coding
// generate also cross-river pawn checks
// 1873t - gen discover checks
int Board::generate_checks(MoveTabStruct *movetab) //(MoveStruct table[], int tabval[])
{
//    static const char noncapstep[2][2] = {-16, 16, -1, 1};
    int nMove=0;
    int DstSq, nDisp, kingpos, kingFile, kingRank; //, xx; //, k, n; //, nStep; //,capture;
    //unsigned char *DstPtr, *EyeLegPtr;
    SlideMoveStruct *lpsmv, *lpsmvRook;
    //MoveTabStruct *tabptr;
    unsigned char *DstPtr, *EyeLegPtr;
//    short *DstPtr2;
    //tabptr = movetab;

    kingpos = boardsq[33-m_side];
//    if (!(NOTSQEMPTY(kingpos)))
//    	return 0;
    kingRank = nRank(kingpos);
    kingFile = nFile(kingpos);

    //gen cannon discovery checks

        // 6. 生成炮的着法  from opp kingpos
            nDisp = (kingRank<<4);  //(y<<3) + y; // * 9; //16;
            lpsmv = PreGen.smvRankMoveTab[kingFile] + wBitRanks[kingRank];
            for (int k=2; k--;)
            {
            for (int n=2; n--;)
            {
                DstSq = lpsmv->CannonCap[n]; // + nDisp;
                //if ((DstSq) !=0)
                if (DstSq != kingpos)
                {
                	DstSq +=nDisp; //-1;
                    if ( (piece[DstSq]&61) == B_ROOK1 + m_side)    //own rook cannoncap opp king
                    {
                      int SrcSqCann = lpsmv->RookCap[n];
                      //if (SrcSq !=0)
                      //{
                      SrcSqCann +=nDisp; //-1;
                      if ( (piece[SrcSqCann]&61) == B_CANNON1 + m_side) // rook-cannon discover check
                      {
                        if (k>0)
                        {
                        	// rook -- cann -- oppking -- opp-piece
                        	int DstSqCann = lpsmv->RookCap[oppside(n)]; //cann capture eq king rookcap
                        	//if (DstSqCann !=0)
                        	if (DstSqCann != kingpos)
                        	{
                        		DstSqCann +=nDisp; //-1;
                        		if ((piece[DstSqCann]&1) != m_side)
                        		{
                        				movetab[nMove].tabentry = (SrcSqCann <<8) + DstSqCann;
                        //movetab[nMove].tabval = m_his_table[DstSqCann][PIECE_IDX16(piece[SrcSq])].HistVal;
                        movetab[nMove].tabval = his_table(PIECE_IDX(piece[SrcSqCann]), DstSqCann);
                        nMove++;
                        }
                      }
                      }
                        /*
                        int nDispRook;
                        if (k==0) //cannon move 90degree
                        {
                        nDispRook = (nRank(SrcSq))<<4;
                        lpsmvRook = PreGen.smvRankMoveTab[nFile(SrcSq)] + wBitRanks[nRank(SrcSq)];
                        }
                        else
                        {
                        nDispRook = nFile(SrcSq);
                        lpsmvRook = PreGen.smvFileMoveTab[nRank(SrcSq)] + wBitFiles[nFile(SrcSq)];
                        }
                        for (int nn=2; nn--;)
            {
                int DstSqRook = lpsmvRook->NonCap[nn]; // + nDisp;
                //if ((DstSqRook) !=0)
                if (DstSqRook != SrcSq)
                {	DstSqRook +=nDispRook; //-1;
                	int nnStep = noncapstep[oppside(k)][nn];

                while ((DstSqRook) != SrcSq)
                {
                        movetab[nMove].tabentry = (SrcSq <<8) + DstSqRook;
                        //movetab[nMove].tabval = m_his_table[DstSqRook][PIECE_IDX16(piece[SrcSq])].HistVal;
                        nMove++;

        								DstSqRook += nnStep;
      					}
               }
            } // end for nn
             */
                }
                // rook -- horse -- oppking
                else if ( (piece[SrcSqCann]&61) == B_HORSE1 + m_side) // horse discover check
                {
                	//if (k==0) //rook-horse up-down
                	{
            DstPtr = g_KnightMoves[SrcSqCann];
            EyeLegPtr = g_HorseLegs[SrcSqCann];
            int DstSqHorse = *DstPtr;
            while (DstSqHorse !=0) //>=0) //!=255) // >= 0)
            {
                if (piece[*EyeLegPtr] == 0)
                {		DstSqHorse--;
                    if (piece[DstSqHorse]==0 )
                    {
                        //int nDispHorse=horsdiff[DstSqHorse-kingpos]; // +90];
                        if (horsdiff[DstSqHorse-kingpos] ==0) //not already gen horse checking
                        {
                            movetab[nMove].tabentry = (SrcSqCann <<8) + DstSqHorse;
                            //movetab[nMove].tabval = m_his_table[DstSqHorse][PIECE_IDX16(piece[SrcSq])].HistVal;
                            movetab[nMove].tabval = his_table(PIECE_IDX(piece[SrcSqCann]), DstSqHorse);
                            nMove++;
                        }
                    }
                }
                DstPtr ++;
                DstSqHorse = *DstPtr;
                EyeLegPtr ++;
            }

                }
              }
            }
            }


                DstSq = lpsmv->SuperCap[n]; // + nDisp;
                //if ((DstSq) !=0)
                if (DstSq != kingpos)
                {
                	DstSq +=nDisp; //-1;
                    if ( (piece[DstSq]&61) == B_CANNON1 + m_side)
                    {
                      int SrcSqRook = lpsmv->CannonCap[n];
                      //if (SrcSqRook !=0)
                      //{
                      SrcSqRook +=nDisp; //-1;
                      if ( (piece[SrcSqRook]&61) == B_ROOK1 + m_side) // cannon-rook-xx-king discover check
                      {
                        int nDispRook;
                        if (k==0) //rook move 90degree
                        {
                        nDispRook = (nRank(SrcSqRook))<<4;
                        lpsmvRook = PreGen.smvRankMoveTab[nFile(SrcSqRook)] + wBitRanks[nRank(SrcSqRook)];
                        }
                        else
                        {
                        nDispRook = nFile(SrcSqRook);
                        lpsmvRook = PreGen.smvFileMoveTab[nRank(SrcSqRook)] + wBitFiles[nFile(SrcSqRook)];
                        }
                        for (int nn=2; nn--;)
            {
                int DstSqRook = lpsmvRook->NonCap[nn]; // + nDisp;
                //if ((DstSqRook) != 0)
                if (DstSqRook != SrcSqRook)
                {	DstSqRook +=nDispRook; //-1;
                	int nnStep = noncapstep[oppside(k)][nn];

                while ((DstSqRook) != SrcSqRook)
                {
                        movetab[nMove].tabentry = (SrcSqRook <<8) + DstSqRook;
                        //movetab[nMove].tabval = m_his_table[DstSqRook][PIECE_IDX16(piece[SrcSq])].HistVal;
                        movetab[nMove].tabval = his_table(PIECE_IDX(piece[SrcSqRook]), DstSqRook);
                        nMove++;

        								DstSqRook += nnStep;
      					}
               }
            } // end for nn

                }
                else if ( (piece[SrcSqRook]&61) == B_HORSE1 + m_side) // cann-horse-xx-king discover check
                {
            DstPtr = g_KnightMoves[SrcSqRook];
            EyeLegPtr = g_HorseLegs[SrcSqRook];
            int DstSqHorse = *DstPtr;
            while (DstSqHorse !=0) //>=0) //!=255) // >= 0)
            {
                if (piece[*EyeLegPtr] == 0)
                {		DstSqHorse--;
                    if (piece[DstSqHorse]==0 )
                    {
                        //int nDispHorse=horsdiff[DstSqHorse-kingpos]; // +90];
                        if (horsdiff[DstSqHorse-kingpos] ==0) //not already gen horse checking
                        {
                            movetab[nMove].tabentry = (SrcSqRook <<8) + DstSqHorse;
                            //movetab[nMove].tabval = m_his_table[DstSqHorse][PIECE_IDX16(piece[SrcSq])].HistVal;
                            movetab[nMove].tabval = his_table(PIECE_IDX(piece[SrcSqRook]),DstSqHorse);
                            nMove++;
                        }
                    }
                }
                DstPtr ++;
                DstSqHorse = *DstPtr;
                EyeLegPtr ++;
            }

                }
            }
            }

            } // end n

						if (k>0) {
            nDisp = kingFile;
            lpsmv = PreGen.smvFileMoveTab[kingRank] + wBitFiles[kingFile];
          }
        } // end k

//cannon and ROOK ;
    for (int bb=rook_index[m_side]; bb>=24; bb-=2)
    {
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
            int y = nRank(SrcSq); // / 16;
            int x = nFile(SrcSq); //SrcSq - nDisp; //nFile(SrcSq); // % 16;
            if ((x != kingFile) && (y != kingRank))
            {

            //for (int k=2; k--;)
            //if (piece[(y<<4)+kingFile]==0)
            {
            	//nDisp = (y<<4);  //(y<<3) + y; // * 9; //16;
              lpsmv = PreGen.smvRankMoveTab[x ] + wBitRanks[y];

            //for (int n=2; n--;)
            //{
            int nStep;
            if (x>kingFile)
            {	 //n=1;
            	DstSq = lpsmv->NonCap[1];
            	nStep = 1;
            }
            else
            {
            	//n=0;
                DstSq = lpsmv->NonCap[0]; // + nDisp;
                nStep = -1;
            }
                //if ((DstSq) !=0)
                if (DstSq != SrcSq)
                {	DstSq +=(y<<4); //-1; //nDisp-1;
                //	int nStep = noncapstep[1][n];
            	  //int nStep = (n<<(5-(k*4))) - (1<<(4-(k*4)));
            	  //int nStep = (n<<1) - 1;
                while ((DstSq) != SrcSq)
                {
                            //int yDst = nRank(DstSq);
                            int xDst = nFile(DstSq);
                            if ( (xDst == kingFile) )
                            {
                                //int save_wBitRanks_y = wBitRanks[y ];
                                //wBitRanks[y ] ^= PreGen.wBitRankMask[SrcSq];  // / 9
                                int save_wBitFiles_x = wBitFiles[x ];
                                wBitFiles[x ] ^= PreGen.wBitFileMask[SrcSq];  // % 9

                                // 2. 如果没有被吃的棋子，那么更新目标格的位行和位列。
                                //    换句话说，有被吃的棋子，目标格的位行和位列就不必更新了。
                                //if (piecedest==EMPTY)
                                //{
                                //int save_wBitRanks_yDst = wBitRanks[yDst ];
                                //wBitRanks[yDst ] ^= PreGen.wBitRankMask[DstSq];
                                int save_wBitFiles_xDst = wBitFiles[xDst ];
                                wBitFiles[xDst ] ^= PreGen.wBitFileMask[DstSq];
                                //}
                          //      boardsq[bb] = DstSq;
                          //      piece[DstSq]=bb;
                          //      piece[SrcSq]=EMPTY;
                                //chgside(m_side);
                                //incheck=IsInCheckbyRookCann(DstSq, bb);
    SlideMaskStruct *kingFileMask; //, *kingRankMask;
//    int kingRank = nRank(kingpos); // / 9;
//    int kingFile = nFile(kingpos); //kingpos - ((y<<3) + y); //(y * 9); //nFile(kingpos); // % 9;
//    kingRankMask = PreGen.smsRankMaskTab[kingFile ] + wBitRanks[kingRank];
    kingFileMask = PreGen.smsFileMaskTab[kingRank ] + wBitFiles[kingFile];
    // 5. 判断是否被车将军
      //  ( ((kingFile == xDst) //nFile(DstSq))
            if (( (bb>=28 ? kingFileMask->RookCap : kingFileMask->CannonCap)
            & PreGen.wBitFileMask[DstSq]) != 0)
    {
    	movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
      //movetab[nMove].tabval = m_his_table[DstSq][PIECE_IDX16(bb)].HistVal;
      movetab[nMove].tabval = his_table(PIECE_IDX(bb), DstSq);
      nMove++;
    }
                                //chgside(m_side);
                        //        piece[SrcSq]=bb; //piece[DstSq];
                        //        piece[DstSq]=EMPTY;
                        //        boardsq[bb] = SrcSq;
                                //wBitRanks[yDst] ^= PreGen.wBitRankMask[DstSq];
                                //wBitFiles[xDst] ^= PreGen.wBitFileMask[DstSq];
//wBitRanks[yDst] = save_wBitRanks_yDst;
wBitFiles[xDst] = save_wBitFiles_xDst;
                                //wBitRanks[y] ^= PreGen.wBitRankMask[SrcSq];
                                //wBitFiles[x] ^= PreGen.wBitFileMask[SrcSq];
//wBitRanks[y] = save_wBitRanks_y;
wBitFiles[x] = save_wBitFiles_x;
                      break; //no need to check further after passing the same file/rank as king
                    }
        								DstSq += nStep;
      					}
               }
            //} // end for n

        } // end k=1

            //gen down and up move
            //for (int k=2; k--;)
            //if (piece[(kingRank<<4)+x]==0)
            {
              //nDisp = x;
            	lpsmv = PreGen.smvFileMoveTab[y ] + wBitFiles[x];
            	int nStep;
            if (y>kingRank)
            {	DstSq = lpsmv->NonCap[1];
            	nStep = 16;
            	//n=1;
			}
            else
            {	//n=0;
            		DstSq = lpsmv->NonCap[0];
            	nStep = -16;
            }
            //for (int n=2; n--;)
            //{
                //DstSq = lpsmv->NonCap[n]; // + nDisp;
                //if ((DstSq) !=0)
                if (DstSq != SrcSq)
                {	DstSq +=x; //-1; //nDisp-1;
                //	int nStep = noncapstep[0][n];
            	  //int nStep = (n<<(5-(k*4))) - (1<<(4-(k*4)));
            	  //int nStep = (n<<5) - 16;
                while ((DstSq) != SrcSq)
                {
                            int yDst = nRank(DstSq);
                            //int xDst = nFile(DstSq);
                            if ( (yDst == kingRank) )
                            {
                                int save_wBitRanks_y = wBitRanks[y ];
                                wBitRanks[y ] ^= PreGen.wBitRankMask[SrcSq];  // / 9
                                //int save_wBitFiles_x = wBitFiles[x ];
                                //wBitFiles[x ] ^= PreGen.wBitFileMask[SrcSq];  // % 9

                                // 2. 如果没有被吃的棋子，那么更新目标格的位行和位列。
                                //    换句话说，有被吃的棋子，目标格的位行和位列就不必更新了。
                                //if (piecedest==EMPTY)
                                //{
                                int save_wBitRanks_yDst = wBitRanks[yDst ];
                                wBitRanks[yDst ] ^= PreGen.wBitRankMask[DstSq];
                                //int save_wBitFiles_xDst = wBitFiles[xDst ];
                                //wBitFiles[xDst ] ^= PreGen.wBitFileMask[DstSq];
                                //}
                          //      boardsq[bb] = DstSq;
                          //      piece[DstSq]=bb;
                          //      piece[SrcSq]=EMPTY;
                                //chgside(m_side);
                                //incheck=IsInCheckbyRookCann(DstSq, bb);
    SlideMaskStruct *kingRankMask; //, *kingFileMask;
//    int kingRank = nRank(kingpos); // / 9;
//    int kingFile = nFile(kingpos); //kingpos - ((y<<3) + y); //(y * 9); //nFile(kingpos); // % 9;
    kingRankMask = PreGen.smsRankMaskTab[kingFile ] + wBitRanks[kingRank];
//    kingFileMask = PreGen.smsFileMaskTab[kingRank ] + wBitFiles[kingFile];
    // 5. 判断是否被车将军
        //if (( ((kingRank == yDst) //nRank(DstSq))
            if (( (bb>=28 ? kingRankMask->RookCap : kingRankMask->CannonCap)
            & PreGen.wBitRankMask[DstSq]) != 0)
    {
    	movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
      //movetab[nMove].tabval = m_his_table[DstSq][PIECE_IDX16(bb)].HistVal;
      movetab[nMove].tabval = his_table(PIECE_IDX(bb), DstSq);
      nMove++;
    }
                                //chgside(m_side);
                        //        piece[SrcSq]=bb; //piece[DstSq];
                        //        piece[DstSq]=EMPTY;
                        //        boardsq[bb] = SrcSq;
                                //wBitRanks[yDst] ^= PreGen.wBitRankMask[DstSq];
                                //wBitFiles[xDst] ^= PreGen.wBitFileMask[DstSq];
wBitRanks[yDst] = save_wBitRanks_yDst;
//wBitFiles[xDst] = save_wBitFiles_xDst;
                                //wBitRanks[y] ^= PreGen.wBitRankMask[SrcSq];
                                //wBitFiles[x] ^= PreGen.wBitFileMask[SrcSq];
wBitRanks[y] = save_wBitRanks_y;
//wBitFiles[x] = save_wBitFiles_x;
                      break; //no need to check further after passing the same file/rank as king
                    }
        								DstSq += nStep;
      					}
               }
            //} // end for n

        } // end k=0

        }
        } // end for SrcSq


    } // for bb


//HORSE
#ifdef HORSECK
//int kingposidx = kingindex[kingpos];
//generate hors checks using pre-gen g_KinightChecks
	for (int bb=hors_index[m_side]; bb>=20; bb-=2)
  {
    if (NOTSQEMPTY(boardsq[bb]))
    {
    	int SrcSq = boardsq[bb];
    	//if (OPPHALF(SrcSq, m_side)) // most likely checks from cross-river
    	//if (abs(nRank(SrcSq) - kingRank) <=4)
    	{

      //for (int j=2; j--;)
      //{
      DstSq = g_KnightChecks[SrcSq][kingindex[kingpos]][1];
      if (DstSq !=0)
      {
        	if (
        		   piece[DstSq + horsdiff[SrcSq-DstSq]]==0
        		&& piece[DstSq]==0
          	&& piece[kingpos + horsdiff[DstSq-kingpos]]==0
          	 )
          {
            movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
            //movetab[nMove].tabval = m_his_table[DstSq][PIECE_IDX16(bb)].HistVal;
            movetab[nMove].tabval = his_table(PIECE_IDX(bb), DstSq);
            nMove++;
          }
        DstSq = g_KnightChecks[SrcSq][kingindex[kingpos]][0];
        if (DstSq !=0)
        {
        	if (
        		   piece[DstSq + horsdiff[SrcSq-DstSq]]==0
        		&& piece[DstSq]==0
          	&& piece[kingpos + horsdiff[DstSq-kingpos]]==0
          	 )
          {
            movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
            //movetab[nMove].tabval = m_his_table[DstSq][PIECE_IDX16(bb)].HistVal;
			movetab[nMove].tabval = his_table(PIECE_IDX(bb), DstSq);
            nMove++;
          }
        }
      }
      //else break;
     //} // end for j
    } // end if OPPHALF

    }	// end if NOTSQEMPTY
  } // end for bb

#else
//for (int bb=22+m_side; bb>=20; bb-=2)
for (int bb=hors_index[m_side];  bb>=20; bb-=2)
    {
        		if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
        	//if (OPPHALF(SrcSq, m_side))
        if (abs(nRank(SrcSq) - kingRank) <=4)
        {	//int piecefrom = (20+m_side+bb) ; //piece[SrcSq];
            DstPtr = g_KnightMoves[SrcSq];
            EyeLegPtr = g_HorseLegs[SrcSq];
            DstSq = *DstPtr;
            while (DstSq !=0) //>=0) //!=255) // >= 0)
            {
                if (piece[*EyeLegPtr] == 0)
                {		DstSq--;
                    if (piece[DstSq]==0 )
                    {
                        int nDisp=horsdiff[DstSq-kingpos]; // +90];
                        if (nDisp !=0 && (piece[kingpos+nDisp]==0))
                        {
                            movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                            //movetab[nMove].tabval = m_his_table[DstSq][PIECE_IDX16(bb)].HistVal;
                            movetab[nMove].tabval = his_table(PIECE_IDX(bb),DstSq);
                            nMove++;
                        }
                    }
                }
                DstPtr ++;
                DstSq = *DstPtr;
                EyeLegPtr ++;
            }
        }
      }
    } // for bb
#endif

if ((bitattk[1-m_side] | bitattk[3-m_side] | bitattk[5-m_side] ) & (0x00000554 <<m_side))
{
    // PAWN
//    ....P....
//    ...P.P...
//    ..P.K.P..
		int z[3]={ kingpos+1, kingpos-1, kingpos - 16 + (m_side << 5)};
    //int SrcSq, pieceS;
    for (int i=3; i--;)
    {
    	if (piece[z[i]]==0)
      {
    		int SrcSq = z[i] - 16 + (m_side <<5);
    		int pieceS = piece[SrcSq];
    	if (pieceS <= R_PAWN5 && pieceS && ((pieceS & 1)==m_side))
    	{

    		movetab[nMove].tabentry = (SrcSq <<8) + z[i];
        //movetab[nMove].tabval = m_his_table[z[i]][PIECE_IDX16(pieceS)].HistVal;
        movetab[nMove].tabval = his_table(PIECE_IDX(pieceS), z[i]);
        nMove++;
    	}

    	for (int j=2; j--;)
    	{
    		if (j!=i)
    	{
    		int SrcSq = z[i]+j+j-1;	//+1, -1
    	  int pieceS = piece[SrcSq];
    	if (pieceS <= R_PAWN5 && pieceS && ((pieceS & 1)==m_side))
    	{	movetab[nMove].tabentry = (SrcSq <<8) + z[i];
        //movetab[nMove].tabval = m_his_table[z[i]][PIECE_IDX16(pieceS)].HistVal;
        movetab[nMove].tabval = his_table(PIECE_IDX(pieceS), z[i]);
        nMove++;
    	}
    }
    }

    }
  }

/*
    //for (int bb=10+m_side; bb>pawn_index[m_side]; bb-=2)
    for (int bb=pawn_index[m_side]; bb>=2; bb-=2)
    {
        //SrcSq = boardsq[bb];
        //if (SrcSq >=0)
        //	if (NOTSQEMPTY(SrcSq))
        //{
        if (NOTSQEMPTY(boardsq[bb]))
        {
            int SrcSq = boardsq[bb];
                //&& (m_side == int(SrcSq <80))	// cross-river
                if (c_LegalMoveTab[SrcSq - kingpos] >= 3)  //3 or 4

        {
            DstPtr = g_PawnMoves[SrcSq][m_side];
            DstSq = *DstPtr;
            while (DstSq !=0) //!=255) //>= 0)
            {	DstSq--;
                if (piece[DstSq]==0
                        //&& ( nFile(DstSq)==nFile(kingpos)
                        //     || DstSq==kingpos+1 || DstSq==kingpos-1)
                        && (c_LegalMoveTab[DstSq - kingpos] == 1)
                   )
                {
                    movetab[nMove].tabentry = (SrcSq <<8) + DstSq;
                    movetab[nMove].tabval = m_his_table[DstSq][PIECE_IDX16(bb)].HistVal;

                    nMove++;

                }
                DstPtr ++;
                DstSq = *DstPtr;
            }  // end while
            //}
            }
        } // end if SrcSq
    } // end for bb
*/
}






    //return (int)(tabptr - movetab) ; // no need to divide sizeof, strange behaviour of pointer!! / sizeof(*tabptr) ;
    return nMove;
}

//inline
//template<int chkreq>
int Board::makemove(MoveStruct &moveS, int chkreq)
{
		//static const int c_piece_idx[34] = {0,1,0,1,0,1,0,1,0,1,0,1,2,3,2,3,2,3,2,3,4,5,4,5,6,7,6,7,8,9,8,9,0,1};
		HistRecord *hisptr;
    hisptr = m_hisrecord + m_hisindex;
    int from=moveS.from;
    int dest=moveS.dest;
    int piecefrom=piece[from];
    int piecedest=piece[dest];
    int nRankfrom = nRank(from);
    int nFilefrom = nFile(from);
    int nRankdest = nRank(dest);
    int nFiledest = nFile(dest);
    int pieceidx;


    wBitRanks[nRankfrom ] ^= PreGen.wBitRankMask[from];  // / 9
    wBitFiles[nFilefrom ] ^= PreGen.wBitFileMask[from];  // % 9

    // 2. 如果没有被吃的棋子，那么更新目标格的位行和位列。
    //    换句话说，有被吃的棋子，目标格的位行和位列就不必更新了。
    if (piecedest==EMPTY)
    {
        wBitRanks[nRankdest ] ^= PreGen.wBitRankMask[dest];
        wBitFiles[nFiledest ] ^= PreGen.wBitFileMask[dest];
    }
    else
    {
        boardsq[piecedest]=SQ_EMPTY;

    }
    boardsq[piecefrom] = dest;
    piece[dest]=piecefrom;
    piece[from]=EMPTY;

		if (chkreq)
    //if (board.IsInCheck(board.m_side, 1)) //singlechk
    if (IsInCheck<1>(m_side)) //singlechk
    {
        piece[from]=piece[dest];
        piece[dest]=piecedest;
        if (piecedest)
        {    boardsq[piecedest] = dest;

			}
        else
        {
            wBitRanks[nRankdest] ^= PreGen.wBitRankMask[dest];
            wBitFiles[nFiledest] ^= PreGen.wBitFileMask[dest];
        }
        wBitRanks[nRankfrom] ^= PreGen.wBitRankMask[from];
        wBitFiles[nFilefrom] ^= PreGen.wBitFileMask[from];
        boardsq[piecefrom] = from;

        return -1;
    }

		hisptr->hkey =hkey;
		//hisptr->from =from;
    //hisptr->dest =dest;
    hisptr->htab.table.move = moveS.move; //(from<<8)+dest; //moveS.move;
    hisptr->htab.capture =piecedest;
    hisptr->pointsum =pointsum;

		hisptr->mvpiece =piecefrom;
    ply++;
    //piecefrom &=29;
    pieceidx=PIECE_IDX(piecefrom);
    //Xor(hkey,h_value[from][piecefrom]);
    //Xor(hkey,h_value[dest][piecefrom]);
    //Xor(hkey,h_value[from][pieceidx]);
    //Xor(hkey,h_value[dest][pieceidx]);
    Xor(hkey,h_value[pieceidx][nFilefrom][nRankfrom]);
    Xor(hkey,h_value[pieceidx][nFiledest][nRankdest]);

    pointsum += pointtable[pieceidx][nRankdest][nFiledest]
              - pointtable[pieceidx][nRankfrom][nFilefrom];
    //pointsum += (board.m_side ? -pointsum_inc : pointsum_inc);


    if (ATTKAREA[from] != ATTKAREA[dest])
    {
        bitattk[ATTKAREA[from]] ^= (1 << piecefrom);
        bitattk[ATTKAREA[dest]] ^= (1 << piecefrom);
    }


    if (piecedest!=EMPTY)
    {
        pieceidx=PIECE_IDX(piecedest);
        //Xor(hkey,h_value[dest][piecedest &29]);
        //Xor(hkey,h_value[dest][pieceidx]);
        Xor(hkey, h_value[pieceidx][nFiledest][nRankdest]);

        pointsum -= pointtable[pieceidx][nRankdest][nFiledest];
        //pointsum += (board.m_side ? -pointtable[pieceidx][nRankdest][nFiledest] : pointtable[pieceidx][nRankdest][nFiledest]);

        //if ((piecedest & 32)==0) // not king
        bitpiece ^= (1 << piecedest); //BITPIECE_MASK[piecedest];
        piececnt[piecedest &61]--;

        bitattk[ATTKAREA[dest]] ^= (1 << piecedest);

        hisptr->endgame =p_endgame;
        if (p_endgame==0 && piecedest >= B_HORSE1)
        {
        // endgame if attacking pieces (R,C,H) <=2 or no nooks
        if (bitCountMSB(bitpiece & 0x55500000) <=2 || bitCountMSB(bitpiece & 0xaaa00000) <=2
        //if (bitCount(bitpiece & 0xfff00000) <=6
        //if (bitCountLSB((bitpiece & 0xfff00000)>>16) <=6
        //if (bitCountMSB((bitpiece & 0xfff00000)) <=6  //6
                || (bitpiece & 0xf0000000) ==0 // no rooks
        //if ( bitCountMSB((bitpiece & 0xf0000000)) * 2 + bitCountMSB((bitpiece & 0x0ff00000)) <=8 //6
           )
          { p_endgame=1;
           	// recalculate pointsum if entering p_endgame
           	pointsum=0;
            for (int i=2; i<34; i++) //i+=2)
            {
              int sq = boardsq[i];
              if (NOTSQEMPTY(sq))
              {
                pointsum += eg_pointtable[PIECE_IDX(i)][nRank(sq)][nFile(sq)];
              }
            }
            /*
            for (int i=3; i<34; i+=2)
            {
              int sq = board.boardsq[i];
              if (NOTSQEMPTY(sq))
              {
                pointsum -= eg_pointtable[PIECE_IDX(i)][nRank(sq)][nFile(sq)];
              }
            }
            */
          }
        }

    }


    Xor(hkey,h_rside);
    chgside(m_side);

    int kingidx=kingindex[boardsq[32+m_side]];
		if (kingattk_incl_horse[kingidx][dest]==0 && kingattk_incl_horse[kingidx][from]==0)
				hisptr->htab.Chk = 0;
		else

    //hisptr->htab.Chk =board.IsInCheck(board.m_side, 0);	// not singlechk = multichk
    hisptr->htab.Chk =IsInCheck<0>(m_side);	// not singlechk = multichk
    m_hisindex++;

		//if (printed==0 )
		//	{	printf("MakeMove: m_side=%d, from=%d, dest=%d, piecefrom=%d, piecedest=%d\n", board.m_side, from, dest, piecefrom, piecedest);
		//printed=1;
		//}

    return piecedest;
}


//inline
void Board::unmakemove() //MoveStruct &moveS)
{
		HistRecord *hisptr;
    m_hisindex--;
    hisptr = m_hisrecord + m_hisindex;
    ply--;
    chgside(m_side);
    hkey=hisptr->hkey ;
    int dest=hisptr->htab.dest;
    int from=hisptr->htab.from;

    //int from=moveS.from;
    //int dest=moveS.dest;
    int piecefrom=piece[dest];
    int piecedest=hisptr->htab.capture;

		pointsum=hisptr->pointsum;

    piece[from]=piecefrom;
    piece[dest]=piecedest;

    if (ATTKAREA[from] != ATTKAREA[dest])
    {
        bitattk[ATTKAREA[from]] ^= (1 << piecefrom);
        bitattk[ATTKAREA[dest]] ^= (1 << piecefrom);
    }


    if (piecedest)
    {
        boardsq[piecedest] = dest;
        //if ((piecedest & 32)==0) // not king
        bitpiece ^= (1 << piecedest); //BITPIECE_MASK[piecedest];
        piececnt[piecedest &61]++;

        bitattk[ATTKAREA[dest]] ^= (1 << piecedest);


				p_endgame=hisptr->endgame;
    }
    else
    {
        wBitRanks[nRank(dest)] ^= PreGen.wBitRankMask[dest];
        wBitFiles[nFile(dest)] ^= PreGen.wBitFileMask[dest];
    }
    wBitRanks[nRank(from)] ^= PreGen.wBitRankMask[from];
    wBitFiles[nFile(from)] ^= PreGen.wBitFileMask[from];
    boardsq[piecefrom] = from;


}

//template<int chkreq>
int Board::makemovenoeval(MoveStruct &moveS, int chkreq)
{
		//static const int c_piece_idx[34] = {0,1,0,1,0,1,0,1,0,1,0,1,2,3,2,3,2,3,2,3,4,5,4,5,6,7,6,7,8,9,8,9,0,1};
		HistRecord *hisptr;
    hisptr = m_hisrecord + m_hisindex;
    int from=moveS.from;
    int dest=moveS.dest;
    int piecefrom=piece[from];
    int piecedest=piece[dest];
    int nRankfrom = nRank(from);
    int nFilefrom = nFile(from);
    int nRankdest = nRank(dest);
    int nFiledest = nFile(dest);
    int pieceidx;


    wBitRanks[nRankfrom ] ^= PreGen.wBitRankMask[from];  // / 9
    wBitFiles[nFilefrom ] ^= PreGen.wBitFileMask[from];  // % 9

    // 2. 如果没有被吃的棋子，那么更新目标格的位行和位列。
    //    换句话说，有被吃的棋子，目标格的位行和位列就不必更新了。
    if (piecedest==EMPTY)
    {
        wBitRanks[nRankdest ] ^= PreGen.wBitRankMask[dest];
        wBitFiles[nFiledest ] ^= PreGen.wBitFileMask[dest];
    }
    else
    {
        boardsq[piecedest]=SQ_EMPTY;

    }
    boardsq[piecefrom] = dest;
    piece[dest]=piecefrom;
    piece[from]=EMPTY;

		if (chkreq)
    //if (board.IsInCheck(board.m_side, 1)) //singlechk
    if (IsInCheck<1>(m_side)) //singlechk
    {
        piece[from]=piece[dest];
        piece[dest]=piecedest;
        if (piecedest)
        {    boardsq[piecedest] = dest;

			}
        else
        {
            wBitRanks[nRankdest] ^= PreGen.wBitRankMask[dest];
            wBitFiles[nFiledest] ^= PreGen.wBitFileMask[dest];
        }
        wBitRanks[nRankfrom] ^= PreGen.wBitRankMask[from];
        wBitFiles[nFilefrom] ^= PreGen.wBitFileMask[from];
        boardsq[piecefrom] = from;

        return -1;
    }

		hisptr->hkey =hkey;
    hisptr->htab.table.move = moveS.move; //(from<<8)+dest; //moveS.move;
    hisptr->htab.capture =piecedest;

    pieceidx=PIECE_IDX(piecefrom);
    Xor(hkey,h_value[pieceidx][nFilefrom][nRankfrom]);
    Xor(hkey,h_value[pieceidx][nFiledest][nRankdest]);

    if (piecedest!=EMPTY)
    {
        pieceidx=PIECE_IDX(piecedest);
        Xor(hkey, h_value[pieceidx][nFiledest][nRankdest]);

    }


    Xor(hkey,h_rside);
    chgside(m_side);

    int kingidx=kingindex[boardsq[32+m_side]];
		if (kingattk_incl_horse[kingidx][dest]==0 && kingattk_incl_horse[kingidx][from]==0)
				hisptr->htab.Chk = 0;
		else

    //hisptr->htab.Chk =board.IsInCheck(board.m_side, 0);	// not singlechk = multichk
    hisptr->htab.Chk =IsInCheck<0>(m_side);	// not singlechk = multichk
    m_hisindex++;

		//if (printed==0 )
		//	{	printf("MakeMove: m_side=%d, from=%d, dest=%d, piecefrom=%d, piecedest=%d\n", board.m_side, from, dest, piecefrom, piecedest);
		//printed=1;
		//}

    return piecedest;
}


//inline
void Board::unmakemovenoeval() //MoveStruct &moveS)
{
		HistRecord *hisptr;
    m_hisindex--;
    hisptr = m_hisrecord + m_hisindex;
    //ply--;
    chgside(m_side);
    hkey=hisptr->hkey ;
    int dest=hisptr->htab.dest;
    int from=hisptr->htab.from;

    //int from=moveS.from;
    //int dest=moveS.dest;
    int piecefrom=piece[dest];
    int piecedest=hisptr->htab.capture;

    piece[from]=piecefrom;
    piece[dest]=piecedest;

    if (piecedest)
    {
        boardsq[piecedest] = dest;

    }
    else
    {
        wBitRanks[nRank(dest)] ^= PreGen.wBitRankMask[dest];
        wBitFiles[nFile(dest)] ^= PreGen.wBitFileMask[dest];
    }
    wBitRanks[nRank(from)] ^= PreGen.wBitRankMask[from];
    wBitFiles[nFile(from)] ^= PreGen.wBitFileMask[from];
    boardsq[piecefrom] = from;


}

//inline
int Board::checkloop(int n)
{
    /* 重复局面检测包括以下几个步骤：
    *
    * 1. 首先判断检测重复的迷你置换表中是否可能有当前局面，如果没有可能，就用不着判断了
    *    置换表"ucRepHash"是ElephantEye的一个特色，局面每执行一个着法时，就会在置换表项中记录下当前的"nMoveNum"
    *    如果置换表项已经填有其他局面，就不必覆盖了，参阅"MakeMove()"函数
    *    因此撤消着法时，只要查找置换表项的值是否等于当前的"nMoveNum"，如果相等则清空该项
    *    如果不等于当前的"nMoveNum"，则说明之前还有局面占有这个置换表项，不必清空该项，参阅"position.h"中的"UndoMakeMove()"函数
    */
    //if (RepHash[hkey & REP_HASH_MASK] == 0) {
    //  return 0;
    //}
    // int sp=m_hisindex-1;
    // if (sp<4) return 0;
    if (m_hisindex<=4) return 0;


    //muller: nullmove is irresible and no need to checkloop
   // if (((m_hisrecord[m_hisindex-1].mvpiece)&1) == ((m_hisrecord[m_hisindex-2].mvpiece)&1))
   // {
    	//printf("nullmove in checkloop\n");
    	//fflush(stdout);
    //	return 0;
  //}
    int sp=m_hisindex-1;
    bool bOppSide, bPerpCheck, bOppPerpCheck;
    bOppSide = bPerpCheck = bOppPerpCheck = true; //1;
	int m = 0;
	//int bChase=0; //, bOppChase;
	//bChase=0; // = bOppChase = 0;
    	//rook chase cannon or cannon chase rook
    //if (((board.piece[m_hisrecord[sp].htab.dest]>>2)==ROOK && (board.piece[m_hisrecord[sp-1].htab.dest]>>2)==CANNON)
    //|| ((board.piece[m_hisrecord[sp].htab.dest]>>2)==CANNON && (board.piece[m_hisrecord[sp-1].htab.dest]>>2)==ROOK))
    //        	bChase = 1;
    for (;sp>=0;sp--)
    {
    		HistRecord m_hisrecord_sp;
    		m_hisrecord_sp = m_hisrecord[sp];
    		if (m_hisrecord_sp.htab.capture)
    				break;
    		//muller: nullmove is irreversible
    		//if (((m_hisrecord_sp.mvpiece)&1) == ((m_hisrecord[sp-1].mvpiece)&1))
    		// but bob hyatt said it costs 8-10 elo
    		//1890p - checkloop(3) testlonppv
    		//if (m_hisrecord_sp.mvpiece==0) // nullmove
    		//	break;


    		// pawn move forward (same nFile) is irreversible
    		if (m_hisrecord_sp.mvpiece <= R_PAWN5
    		&& nFile(m_hisrecord_sp.htab.from) == nFile(m_hisrecord_sp.htab.dest)
    			)
    				break;

        // 4. 判断双方是否还有长将的可能，只要循环着法中的任意一个着法不是将军，就不算长将了
        if (bOppSide) {
            if (bOppPerpCheck && !m_hisrecord_sp.htab.Chk) {
                bOppPerpCheck = false; //0;
            }
        } else {
            if (bPerpCheck && !m_hisrecord_sp.htab.Chk) {
                bPerpCheck = false; //0;
            }
        }


//		if(m_hisrecord[sp].hkey.x1==hkey.x1 &&m_hisrecord[sp].hkey.x2==hkey.x2)
        if (m_hisrecord_sp.hkey==hkey)
        {
            m++;
            if (m>=n)
            {
            		if (bPerpCheck) return ply-BAN_VALUE;
            		if (bOppPerpCheck) return BAN_VALUE-ply;

            		//rook chase cannon or cannon chase rook
            		//int chaser = board.piece[m_hisrecord[m_hisindex-1].htab.dest]; //>>2;
            		//int chasee = board.piece[m_hisrecord[m_hisindex-2].htab.dest]; //>>2;
            		int chaser = m_hisrecord[m_hisindex-1].mvpiece; //>>2;
            		int chasee = m_hisrecord[m_hisindex-2].mvpiece; //>>2;
    //if ((chaser==ROOK && chasee==CANNON)
    //|| (chaser==CANNON && chasee==ROOK))
    //if (chaser>=HORSE && chaser!= KING && chasee>=HORSE && chasee!=KING && chaser!=chasee)
    if ( (chaser <= R_PAWN5 || (chaser >= B_HORSE1 && chaser <= R_ROOK2))
    &&	(chasee <= R_PAWN5 || (chasee >= B_HORSE1 && chasee <= R_ROOK2))
    && (chaser>>2) != (chasee>>2) )
    // check evasion is not chasing ???
    //if (!m_hisrecord[m_hisindex-2].htab.Chk && !m_hisrecord[m_hisindex-4].htab.Chk
    // && !m_hisrecord[m_hisindex-1].htab.Chk && !m_hisrecord[m_hisindex-3].htab.Chk
    //	&& 
    if (IsChasing(m_hisrecord[m_hisindex-1].htab.dest, m_hisrecord[m_hisindex-2].htab.dest))
    {


    	int prevChaserDest = m_hisrecord[m_hisindex-3].htab.dest;
    	int prevChaseeDest = m_hisrecord[m_hisindex-4].htab.dest;
    	MoveStruct tempmove;
    	tempmove.from = m_hisrecord[m_hisindex-1].htab.dest;
    	tempmove.dest = m_hisrecord[m_hisindex-1].htab.from;
    	makemovenoeval(tempmove, 0);
    	tempmove.from = m_hisrecord[m_hisindex-3].htab.dest;
    	tempmove.dest = m_hisrecord[m_hisindex-3].htab.from;
    	makemovenoeval(tempmove, 0);
      int IsPrevChase = IsChasing(prevChaserDest, prevChaseeDest);
      unmakemovenoeval();
      unmakemovenoeval();
      if (IsPrevChase)
      {
            		//if (bOppSide)
            		//	bOppChase = 1;
            		//else
            			//bChase = 1;
/*
#ifdef PRTBOARD
	if (prtboard<10)
	{
		print_board();
		wprintf(L"m_hisindex=%d, chaser=%d %c, chasee=%d %c\n", m_hisindex, chaser, PieceChar[chaser], chasee,PieceChar[chasee]);
		for (int i=0; i<m_hisindex; i++)
		{
			com2char(charmove, m_hisrecord[i].htab.from, m_hisrecord[i].htab.dest );
			wprintf(L"%c", PieceChar[m_hisrecord[i].mvpiece]);
			printf("%s ", charmove);
		}
		printf("\n");
		fflush(stdout);
	}
#endif
*/
            			//return (board.m_side ? board.ply-BAN_VALUE : BAN_VALUE-ply);
            			return ((chaser&1) ? BAN_VALUE-ply : ply-BAN_VALUE);

            }
          }

                // 7. 如果重复次数达到预定次数，则返回重复记号，1表示有重复，2表示本方长将，4表示对方长将
                //return 1 + (bPerpCheck ? 2 : 0) + (bOppPerpCheck ? 4 : 0);

                //return 1 + (bPerpCheck <<1) + (bOppPerpCheck <<2) + (bChase <<3); // + (bOppChase <<4);

        				//return (bPerpCheck ? board.ply-BAN_VALUE : (bOppPerpCheck ? BAN_VALUE-ply : (bChase ? WIN_VALUE-ply : ((board.ply &1) <<5) - DRAWVALUE)));
                //return (((board.m_side) <<5) - DRAWVALUE);
                return (((m_side) * DRAWVALUE *2) - DRAWVALUE);
                //return (board.m_side ? DRAWVALUE : -DRAWVALUE);
                // 参数"nArg"通常用"IsRep"的返回值，第0位表示有重复，第1位(nArg & 2)表示本方长将，第2位(nArg & 4)表示对方长将
				/*
				if ((val &2)!=0) return board.ply - BAN_VALUE;
				if ((val &4)!=0) return BAN_VALUE - board.ply;
				if ((val &8)!=0) return WIN_VALUE - board.ply;
				//if ((val &8)!=0) return board.ply - BAN_VALUE;
				//if ((val &16)!=0) return BAN_VALUE - board.ply;
        //return (board.ply &1) == 0 ? -DRAWVALUE : DRAWVALUE;
        return ((board.ply &1) <<5) - DRAWVALUE;	 //-16 : 16
        */
            }
        }
        bOppSide = !bOppSide;
        //chgside(bOppSide);
    }
    return 0;
}

